<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Infinie & gratuit — Supprimer l’arrière-plan</title>
<meta name="color-scheme" content="dark"/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#0A0A0B; --text:#F2F3F6; --muted:#A5A9B3;
    --gold-1:#D8B45A; --gold-2:#F2C76C; --gold-3:#BF8E2C;
    --panel:#101218CC; --border:rgba(212,172,82,.22);
    --grid:#F2C76C22; --grid-strong:#F2C76C35;
    --radius:14px; --ring:0 0 0 2px rgba(212,172,82,.35);
    --speed-grid:60s; --speed-plane:26s;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    background:var(--bg); color:var(--text); overflow-x:hidden;
  }

  /* ===== BACKGROUND (4 calques) ===== */
  .back{ position:fixed; inset:0; pointer-events:none; z-index:-1; }
  .grid-ortho,.grid-plane,.halo,.vignette{ position:absolute; inset:0; }
  .grid-ortho{
    background:
      linear-gradient(transparent 31px, var(--grid) 32px) 0 0/32px 32px,
      linear-gradient(90deg, transparent 31px, var(--grid) 32px) 0 0/32px 32px;
    mask: radial-gradient(1200px 1200px at 50% 40%, #000 40%, transparent 85%);
    animation: orthoPan var(--speed-grid) linear infinite;
  }
  .grid-plane{
    --gcol: var(--grid-strong);
    background:
      linear-gradient(transparent 18px, var(--gcol) 19px) 50% 85%/100% 20%,
      linear-gradient(90deg, transparent 18px, var(--gcol) 19px) 50% 85%/60% 20%;
    transform: perspective(900px) rotateX(68deg);
    transform-origin: 50% 100%;
    filter: blur(.3px) drop-shadow(0 10px 50px rgba(242,199,108,.05));
    animation: planeFlow var(--speed-plane) linear infinite;
    opacity:.55;
  }
  .halo{
    background:
      radial-gradient(800px 420px at 12% 14%, rgba(242,199,108,.18), transparent 60%),
      radial-gradient(900px 540px at 85% 80%, rgba(191,142,44,.14), transparent 55%);
    mix-blend-mode:screen; opacity:.65;
  }
  .vignette{ box-shadow: inset 0 0 200px 80px #000; }

  @keyframes orthoPan{
    0%{ background-position:0 0,0 0 }
    100%{ background-position:0 32px,32px 0 }
  }
  @keyframes planeFlow{
    0%{ background-position:50% 85%,50% 85% }
    100%{ background-position:50% calc(85% + 200%), 50% calc(85% + 200%) }
  }

  /* ===== HEADER ===== */
  header{
    position:sticky; top:0; display:flex; align-items:center; justify-content:space-between; gap:16px;
    padding:14px 18px; backdrop-filter:saturate(120%) blur(10px);
    background:linear-gradient(180deg, rgba(16,18,24,.78), rgba(16,18,24,.55));
    border-bottom:1px solid var(--border); z-index:5;
  }
  .brand{display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.2px}
  .brand span{user-select:none}
  .logo{
    width:28px; height:28px; border-radius:999px; display:grid; place-items:center;
    color:#0B0B0D; font-weight:800;
    background: radial-gradient(circle at 30% 30%, var(--gold-2), var(--gold-3));
    border:1px solid rgba(255,255,255,.06); box-shadow: inset 0 1px 2px rgba(255,255,255,.2);
  }
  .badge{
    padding:6px 12px; font-size:12px; border-radius:999px; user-select:none;
    background:rgba(16,18,24,.85); color:#f2d48a; border:1px solid var(--border);
  }

  /* ===== LAYOUT ===== */
  .wrap{ max-width:1100px; margin:24px auto 80px; padding:0 18px; display:grid; gap:20px; }
  .grid{ display:grid; gap:20px; grid-template-columns:1.1fr .9fr; }
  @media (max-width:980px){ .grid{ grid-template-columns:1fr } }

  .card{
    background:linear-gradient(160deg, rgba(216,180,90,.06), transparent 40%), var(--panel);
    border:1px solid var(--border); border-radius:var(--radius); padding:18px;
    box-shadow:0 20px 60px rgba(0,0,0,.38), inset 0 1px 0 rgba(255,255,255,.03);
    position:relative;
  }
  .card.center{
    max-width:560px; margin:0 auto; text-align:center; padding:26px 22px;
  }

  h1{ font-size:34px; margin:6px 0 6px; line-height:1.12; }
  .muted{ color:var(--muted); font-size:12.5px }

  /* ===== COMPONENTS ===== */
  .btn{
    background:#10131c; color:var(--text); border:1px solid var(--border);
    border-radius:12px; padding:12px 14px; font-weight:700; font-size:14px; cursor:pointer; user-select:none;
    transition:transform .08s ease, box-shadow .15s ease, border-color .15s ease; outline:none;
  }
  .btn:hover{ box-shadow:var(--ring); border-color:rgba(242,199,108,.45) }
  .btn:active{ transform:translateY(1px) }
  .btn:focus-visible{ box-shadow:var(--ring) }
  .btn.primary{
    background:linear-gradient(90deg, var(--gold-2), var(--gold-3));
    border-color:rgba(242,199,108,.6); color:#0B0B0D;
  }
  .btn.small{ padding:8px 10px; font-size:12px; border-radius:10px }

  label{ display:block; font-size:12px; color:var(--muted); margin-bottom:8px }
  .input, select{
    width:100%; background:#0C0E14; color:var(--text); border:1px solid var(--border);
    border-radius:12px; padding:12px 14px; font-size:14px; outline:none;
  }
  .input:focus-visible, select:focus-visible{ box-shadow:var(--ring) }

  .toolbar{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
  .field{ margin-bottom:16px }

  /* ===== DROPZONE ===== */
  .drop{
    position:relative; width:100%; aspect-ratio:16/10; display:grid; place-items:center;
    border:1.5px dashed rgba(242,199,108,.35); border-radius:14px; color:#e9d9aa;
    background:linear-gradient(180deg, rgba(242,199,108,.05), rgba(191,142,44,.03));
    transition:border-color .2s ease, box-shadow .2s ease, transform .2s ease;
  }
  .drop.drag{ border-color:rgba(242,199,108,.75); box-shadow:var(--ring); transform:scale(1.01) }
  .drop input{ position:absolute; inset:0; opacity:0; pointer-events:none } /* requis */
  .drop .hint{ text-align:center }
  .drop .hint .h1{ font-size:18px; font-weight:800; margin-bottom:6px }

  /* ===== PREVIEW ===== */
  .preview{ position:relative; width:100%; aspect-ratio:16/10; border-radius:14px; overflow:hidden; background:#090f17; user-select:none }
  .preview img,.preview canvas{ position:absolute; inset:0; width:100%; height:100%; object-fit:contain }
  .afterLayer{ position:absolute; inset:0; background:
      conic-gradient(from 0deg at 50% 50%, rgba(255,255,255,.07), rgba(0,0,0,0) 30%, rgba(255,255,255,.07) 60%, rgba(0,0,0,0) 90%);
    pointer-events:none; clip-path:inset(0 0 0 100%); }
  .handle{ position:absolute; top:0; bottom:0; width:3px; left:100%; transform:translateX(-50%);
    background:linear-gradient(var(--gold-2), var(--gold-3)); box-shadow:0 0 0 1px rgba(255,255,255,.08);
    pointer-events:none; opacity:0; }
  .handle.show{ opacity:1; transition:opacity .25s ease }

  .status{ display:flex; align-items:center; gap:8px; color:var(--muted); font-size:12px }
  .dot{ width:8px; height:8px; border-radius:99px; background:#4a4d57 }

  /* ===== OVERLAY (2 anneaux 5–7s) ===== */
  #overlay{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; flex-direction:column; gap:18px;
    background:radial-gradient(900px 500px at 50% 40%, rgba(16,18,24,.9), rgba(16,18,24,.7) 60%, rgba(16,18,24,.85));
    z-index:50;
  }
  #overlay.show{ display:flex }
  #overlayText{ color:#f1e3b0; font-weight:700; letter-spacing:.3px }
  .rings{ position:relative; width:88px; height:88px; display:grid; place-items:center; }
  .ring,.ring2{ position:absolute; border-radius:999px; border:3px solid rgba(255,255,255,.12) }
  .ring{ width:72px; height:72px; border-right-color:rgba(242,199,108,.85); animation:spin 1.15s linear infinite }
  .ring2{ width:88px; height:88px; border-top-color:rgba(191,142,44,.85); animation:spin 1.75s linear infinite reverse }
  @keyframes spin{ to{ transform:rotate(360deg) } }

  /* ===== SUCCESS ===== */
  #done{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; padding:18px; z-index:60; }
  #done.show{ display:flex }
  .ok{
    width:42px; height:42px; border-radius:999px; display:grid; place-items:center; margin:0 auto 10px;
    background:linear-gradient(90deg, var(--gold-2), var(--gold-3)); color:#0B0B0D; font-weight:800;
    box-shadow:0 8px 30px rgba(191,142,44,.25);
  }
  .thanks{ width:110px; height:auto; display:block; margin:0 auto 8px }
  .result-thumb{ width:100%; max-height:260px; object-fit:contain; border-radius:10px; border:1px solid var(--border); background:#0C0E14 }

  .footerLine{ display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; margin-top:12px; color:var(--muted); font-size:12px }

  .hidden{ display:none !important }
</style>
</head>

<body>
  <div class="back">
    <div class="grid-ortho"></div>
    <div class="grid-plane"></div>
    <div class="halo"></div>
    <div class="vignette"></div>
  </div>

  <!-- ===== Header à répliquer tel quel ===== -->
  <header>
    <div class="brand"><div class="logo">∞</div><span>Infinie & gratuit</span></div>
    <div class="badge">Supprimer l’arrière-plan</div>
  </header>

  <main class="wrap">
    <h1>Supprimer l’arrière-plan</h1>
    <p class="muted">Détourage IA local — vos fichiers ne quittent jamais votre appareil.</p>

    <section class="grid">
      <!-- PREVIEW / DROP -->
      <div class="card" id="panel-preview" aria-live="polite">
        <div class="drop" id="drop" tabindex="0" role="button" aria-label="Déposer ou sélectionner une image">
          <div class="hint">
            <div class="h1">Dépose ton image</div>
            <div class="muted">ou clique pour téléverser</div>
          </div>
          <input id="file" type="file" accept="image/*"/>
        </div>

        <div class="preview hidden" id="preview">
          <img id="imgBefore" alt="Image d’entrée"/>
          <div class="afterLayer" id="afterLayer"><canvas id="afterCanvas" aria-label="Résultat du détourage"></canvas></div>
          <div class="handle" id="handle"></div>
          <!-- ROI canvas injecté dynamiquement -->
        </div>

        <div class="footerLine">
          <div class="status">
            <span class="dot" id="modeDot"></span>
            <span id="modeText">Chargement d’OpenCV…</span>
          </div>
          <div id="fileInfo">Aucune image</div>
        </div>
      </div>

      <!-- CONTROLES -->
      <div class="card">
        <div class="field">
          <label>Qualité</label>
          <select class="input" id="quality">
            <option value="medium" selected>Moyenne (rapide)</option>
            <option value="high">Haute (originale)</option>
          </select>
        </div>

        <div class="field">
          <label>Actions</label>
          <div class="toolbar">
            <button class="btn small" id="browseBtn" type="button">Parcourir…</button>
            <button class="btn" id="againBtn" type="button">Réinitialiser</button>
          </div>
        </div>

        <div class="field">
          <div class="toolbar">
            <button class="btn" id="run" type="button" disabled>Lancer</button>
            <button class="btn primary" id="download" type="button" disabled>Télécharger PNG</button>
          </div>
        </div>

        <p class="muted">L’aperçu à droite montre un volet avant/après. “Moyenne” redimensionne pour accélérer.</p>
      </div>
    </section>
  </main>

  <!-- OVERLAY (deux anneaux) -->
  <div id="overlay" aria-live="polite">
    <div class="rings">
      <div class="ring"></div>
      <div class="ring2"></div>
    </div>
    <div id="overlayText">Traitement en cours…</div>
  </div>

  <!-- SUCCESS -->
  <div id="done" role="dialog" aria-modal="true" aria-labelledby="doneTitle" aria-describedby="doneDesc">
    <div class="card center">
      <img class="thanks" src="merci.png" alt="Merci"/>
      <div class="ok">✓</div>
      <h3 id="doneTitle" style="margin:6px 0 4px">Arrière-plan supprimé</h3>
      <p id="doneDesc" class="muted" style="margin:0 0 12px">Votre image est prête. Vous pouvez la télécharger ou recommencer.</p>
      <img id="resultThumb" class="result-thumb hidden" alt="Aperçu du résultat"/>
      <div class="toolbar" style="margin-top:14px; justify-content:center">
        <button class="btn primary" id="download2" type="button">Télécharger PNG</button>
        <button class="btn" id="againBtn2" type="button">Recommencer</button>
      </div>
    </div>
  </div>

  <!-- OpenCV.js (WASM) -->
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>

  <script>
  /* ====== Utils ====== */
  const $=(s,r=document)=>r.querySelector(s);
  const wait=ms=>new Promise(r=>setTimeout(r,ms));

  /* ====== DOM ====== */
  const drop = $('#drop');
  const fileInput = $('#file');
  const browseBtn = $('#browseBtn');

  const preview = $('#preview');
  const imgBefore = $('#imgBefore');
  const afterCanvas = $('#afterCanvas');
  const afterLayer = $('#afterLayer');
  const handle = $('#handle');

  const modeText = $('#modeText');
  const modeDot = $('#modeDot');
  const fileInfo = $('#fileInfo');

  const runBtn = $('#run');
  const dlBtn = $('#download');
  const dlBtn2 = $('#download2');
  const againBtn = $('#againBtn');
  const againBtn2 = $('#againBtn2');
  const qualitySel = $('#quality');

  const overlay = $('#overlay');
  const overlayText = $('#overlayText');

  const done = $('#done');
  const resultThumb = $('#resultThumb');

  /* ====== State ====== */
  const MEDIUM_MAX = 1600;
  let openingDialog = false;    // anti double-ouverture
  let imageFile = null, imgReady=false, cvReady=false, resultURL=null;
  let roi=null, roiCanvas=null, roiCtx=null, dragging=false, startPt=null;

  /* ====== Accessibility helpers ====== */
  function setStatusOk(txt){
    modeText.textContent = txt;
    modeDot.style.background = 'linear-gradient(90deg, var(--gold-2), var(--gold-3))';
  }
  function setStatusErr(txt){
    modeText.textContent = '⚠️ ' + txt;
    modeDot.style.background = '#9b2c2c';
  }
  function updateRun(){ runBtn.disabled = !(imgReady && cvReady); }

  /* ====== OpenCV readiness ====== */
  (function waitForCV(){
    function ready(){ cvReady=true; setStatusOk('Moteur prêt'); updateRun(); }
    const check = () => {
      if (window.cv) {
        if (cv.ready && typeof cv.ready.then === 'function') { cv.ready.then(ready); }
        else if ('onRuntimeInitialized' in cv) { cv.onRuntimeInitialized = ready; }
        else {
          const t=setInterval(()=>{ try{ new cv.Mat(); clearInterval(t); ready(); }catch{} },60);
        }
        return true;
      }
      return false;
    };
    if (!check()){
      const t=setInterval(()=>{ if(check()) clearInterval(t); },80);
    }
  })();

  /* ====== Drop / Browse (anti double-click) ====== */
  drop.addEventListener('click', async ()=>{
    if(openingDialog) return;
    openingDialog = true;
    fileInput.click();
    // garde-fou si l’utilisateur annule
    setTimeout(()=>{ openingDialog=false; }, 1200);
  });
  browseBtn.addEventListener('click', ()=> drop.click());
  drop.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); drop.click(); }});

  ['dragover','dragleave','drop'].forEach(ev=>{
    drop.addEventListener(ev, e=>{
      if(ev==='dragover'){ e.preventDefault(); drop.classList.add('drag'); }
      if(ev==='dragleave'){ drop.classList.remove('drag'); }
      if(ev==='drop'){
        e.preventDefault(); drop.classList.remove('drag');
        const f = e.dataTransfer?.files?.[0];
        if(f) onFile(f);
      }
    });
  });
  fileInput.addEventListener('change', e=>{
    openingDialog=false; // autorise un nouveau clic
    const f = e.target.files?.[0];
    if(f) onFile(f);
  });

  /* ====== File handling ====== */
  async function onFile(f){
    imageFile = f; imgReady = false; updateRun();
    const url = URL.createObjectURL(f);
    imgBefore.src = url;
    imgBefore.onload = ()=>{
      afterCanvas.width = imgBefore.naturalWidth || imgBefore.width;
      afterCanvas.height = imgBefore.naturalHeight || imgBefore.height;
      imgReady = true; ensureRoiCanvas(); updateRun();
    };
    fileInfo.textContent = (f.size/1e6).toFixed(2)+' MB';
    drop.classList.add('hidden'); preview.classList.remove('hidden');
    dlBtn.disabled = true;
    afterLayer.style.clipPath='inset(0 0 0 100%)'; handle.style.left='100%'; handle.style.opacity=0; handle.classList.remove('show');
  }

  function resetAll(){
    imageFile=null; imgReady=false; updateRun();
    if(resultURL){ URL.revokeObjectURL(resultURL); resultURL=null; }
    imgBefore.removeAttribute('src');
    const ctx = afterCanvas.getContext('2d'); ctx.clearRect(0,0,afterCanvas.width,afterCanvas.height);
    preview.classList.add('hidden'); drop.classList.remove('hidden');
    dlBtn.disabled = true; dlBtn2.disabled = true;
    afterLayer.style.clipPath='inset(0 0 0 100%)'; handle.style.left='100%'; handle.style.opacity=0; handle.classList.remove('show');
    fileInfo.textContent='Aucune image';
    if(roiCanvas){ roiCanvas.remove(); roiCanvas=null; roiCtx=null; }
    roi=null; dragging=false; startPt=null;
    fileInput.value=''; // reset volontaire
  }
  againBtn.addEventListener('click', resetAll);
  againBtn2.addEventListener('click', ()=>{ resetAll(); done.classList.remove('show'); });

  /* ====== ROI overlay ====== */
  function ensureRoiCanvas(){
    if (roiCanvas) return;
    roiCanvas = document.createElement('canvas');
    roiCanvas.style.position='absolute';
    roiCanvas.style.inset='0';
    roiCanvas.style.pointerEvents='auto';
    preview.appendChild(roiCanvas);
    roiCtx = roiCanvas.getContext('2d');
    resizeRoiCanvas();
    window.addEventListener('resize', resizeRoiCanvas);
    roiCanvas.addEventListener('mousedown', onDown);
    roiCanvas.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  }
  function resizeRoiCanvas(){
    if(!roiCanvas) return;
    const r = preview.getBoundingClientRect();
    roiCanvas.width = Math.round(r.width);
    roiCanvas.height= Math.round(r.height);
    drawRoi();
  }
  function drawRoi(){
    if(!roiCtx) return;
    roiCtx.clearRect(0,0,roiCanvas.width,roiCanvas.height);
    if(!roi) return;
    roiCtx.lineWidth = 2;
    roiCtx.setLineDash([6,4]);
    roiCtx.strokeStyle = '#F2C76C';
    const rect = imgRectToCanvas(roi);
    roiCtx.strokeRect(rect.x, rect.y, rect.w, rect.h);
  }
  function onDown(e){
    if(!imgReady) return;
    const p = toImageCoords(e.offsetX, e.offsetY);
    if(!p) return;
    dragging=true; startPt=p; roi={x:p.x,y:p.y,w:0,h:0}; drawRoi();
  }
  function onMove(e){
    if(!dragging || !startPt) return;
    const p = toImageCoords(e.offsetX, e.offsetY); if(!p) return;
    roi = { x: Math.min(startPt.x,p.x), y: Math.min(startPt.y,p.y),
            w: Math.abs(p.x-startPt.x), h: Math.abs(p.y-startPt.y) };
    drawRoi();
  }
  function onUp(){ dragging=false; startPt=null; drawRoi(); }

  function toImageCoords(px,py){
    const cw = roiCanvas.width, ch = roiCanvas.height;
    const iw = imgBefore.naturalWidth, ih = imgBefore.naturalHeight;
    if(!iw||!ih) return null;
    const s = Math.min(cw/iw, ch/ih);
    const wd = Math.round(iw*s), hd = Math.round(ih*s);
    const ox = Math.floor((cw-wd)/2), oy = Math.floor((ch-hd)/2);
    if(px<ox||py<oy||px>ox+wd||py>oy+hd) return null;
    return { x: Math.max(0, Math.min(iw-1, Math.round((px-ox)/s))),
             y: Math.max(0, Math.min(ih-1, Math.round((py-oy)/s))) };
  }
  function imgRectToCanvas(r){
    const cw = roiCanvas.width, ch = roiCanvas.height;
    const iw = imgBefore.naturalWidth, ih = imgBefore.naturalHeight;
    const s = Math.min(cw/iw, ch/ih);
    const wd = Math.round(iw*s), hd = Math.round(ih*s);
    const ox = Math.floor((cw-wd)/2), oy = Math.floor((ch-hd)/2);
    return { x: Math.round(ox + r.x*s), y: Math.round(oy + r.y*s),
             w: Math.round(r.w*s), h: Math.round(r.h*s) };
  }

  /* ====== Core processing ====== */
  runBtn.addEventListener('click', async ()=>{
    if(runBtn.disabled){ setStatusErr('Choisis une image'); return; }

    // Overlay 5.5–7s minimum
    overlay.classList.add('show');
    overlayText.textContent = 'Préparation du modèle…';
    const tMin = wait(5600);

    try{
      await Promise.all([runMatting(), tMin]);
      // succès → écran "done"
      if(resultURL){
        resultThumb.src = resultURL;
        resultThumb.classList.remove('hidden');
        dlBtn2.disabled = false;
      }
      done.classList.add('show');
    }catch(e){
      setStatusErr(e?.message || String(e));
    }finally{
      overlay.classList.remove('show');
    }
  });

  dlBtn.addEventListener('click', downloadImage);
  dlBtn2.addEventListener('click', downloadImage);

  async function runMatting(){
    try{
      setStatusOk('Segmentation… (IMG.LY)');
      overlayText.textContent = 'Segmentation (IA)…';

      // Essayez d’abord IMG.LY
      const { removeBackground } = await import('https://cdn.jsdelivr.net/npm/@imgly/background-removal@1/+esm');
      const input = imageFile || (await (await fetch(imgBefore.src)).blob());
      const outBlob = await removeBackground(input); // PNG avec alpha

      const bmp = await createImageBitmap(outBlob);
      afterCanvas.width = bmp.width; afterCanvas.height = bmp.height;
      afterCanvas.getContext('2d').drawImage(bmp, 0, 0);

      if (resultURL) URL.revokeObjectURL(resultURL);
      resultURL = URL.createObjectURL(outBlob);
      dlBtn.disabled = false;
      reveal();
      setStatusOk('Arrière-plan supprimé — IMG.LY');
      return;
    }catch(e){
      console.warn('IMG.LY KO → fallback local', e);
    }

    // ==== Fallback local (GrabCut + QuickMatte + Guided) ====
    overlayText.textContent = 'Segmentation (locale)…';
    await imgBefore.decode?.();

    const W0 = imgBefore.naturalWidth, H0 = imgBefore.naturalHeight;
    const high = (qualitySel.value==='high');
    const targetMax = high ? Math.max(W0,H0) : MEDIUM_MAX;
    const scale = Math.min(1, targetMax/Math.max(W0,H0));
    const W = Math.round(W0*scale), H = Math.round(H0*scale);

    const src = document.createElement('canvas'); src.width=W; src.height=H;
    src.getContext('2d').drawImage(imgBefore,0,0,W,H);

    let R = roi ? { x: Math.round(roi.x*scale), y: Math.round(roi.y*scale),
                    w: Math.round(roi.w*scale), h: Math.round(roi.h*scale) }
                : centralRect(W,H);
    if(R.w<12||R.h<12) R = centralRect(W,H);

    // GrabCut
    let alpha=null, ok=false;
    try{
      const srcMat = cv.imread(src);
      const bgr = new cv.Mat(); cv.cvtColor(srcMat, bgr, cv.COLOR_RGBA2BGR);
      const smooth=new cv.Mat(); cv.bilateralFilter(bgr, smooth, 9, 75, 75);
      const mask=cv.Mat.zeros(H,W,cv.CV_8U), bgd=new cv.Mat(), fgd=new cv.Mat();

      cv.grabCut(smooth, mask, new cv.Rect(R.x,R.y,R.w,R.h), bgd, fgd, 5, cv.GC_INIT_WITH_RECT);

      alpha=new Uint8ClampedArray(W*H);
      let sumA=0;
      for(let i=0;i<mask.data.length;i++){
        const v=mask.data[i]; const a=(v===cv.GC_FGD||v===cv.GC_PR_FGD)?255:0;
        alpha[i]=a; sumA+=a;
      }

      if(sumA < W*H*0.005){
        const grow=0.12;
        const Rx = Math.max(0, Math.round(R.x - R.w*grow));
        const Ry = Math.max(0, Math.round(R.y - R.h*grow));
        const Rw = Math.min(W-Rx, Math.round(R.w*(1+2*grow)));
        const Rh = Math.min(H-Ry, Math.round(R.h*(1+2*grow)));
        mask.setTo(new cv.Scalar(0));
        cv.grabCut(smooth, mask, new cv.Rect(Rx,Ry,Rw,Rh), bgd, fgd, 5, cv.GC_INIT_WITH_RECT);
        sumA=0;
        for(let i=0;i<mask.data.length;i++){ const v=mask.data[i]; const a=(v===cv.GC_FGD||v===cv.GC_PR_FGD)?255:0; alpha[i]=a; sumA+=a; }
      }

      srcMat.delete(); bgr.delete(); smooth.delete(); mask.delete(); bgd.delete(); fgd.delete();
      if(sumA >= W*H*0.002) ok=true;
    }catch(e){ console.warn('GrabCut KO:', e); }

    // QuickMatte fallback
    if(!ok){
      const alphaQM = quickMatteFromBorder(src);
      alpha = alphaQM;
    }

    const mMat = cv.matFromArray(H,W,cv.CV_8U, alpha);
    const k3 = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3,3));
    const k5 = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5,5));
    cv.morphologyEx(mMat, mMat, cv.MORPH_OPEN, k3);
    cv.morphologyEx(mMat, mMat, cv.MORPH_CLOSE, k5);
    cv.GaussianBlur(mMat, mMat, new cv.Size(3,3), 0);

    const rgba = src.getContext('2d').getImageData(0,0,W,H);
    const guided = guidedFilterAlpha(rgba.data, mMat.data, W,H, 8, 1e-3);

    if(high && scale<1){
      const tmp=document.createElement('canvas'); tmp.width=W; tmp.height=H;
      const tctx=tmp.getContext('2d'); const img=tctx.createImageData(W,H);
      for(let i=0,j=0;i<img.data.length;i+=4,j++){ img.data[i]=rgba.data[i]; img.data[i+1]=rgba.data[i+1]; img.data[i+2]=rgba.data[i+2]; img.data[i+3]=guided[j]; }
      tctx.putImageData(img,0,0);
      afterCanvas.width=W0; afterCanvas.height=H0;
      const ctx=afterCanvas.getContext('2d'); ctx.imageSmoothingEnabled=true;
      ctx.drawImage(tmp,0,0,W,H,0,0,W0,H0);
    }else{
      afterCanvas.width=W; afterCanvas.height=H;
      const ctx=afterCanvas.getContext('2d'); const img=ctx.createImageData(W,H);
      for(let i=0,j=0;i<img.data.length;i+=4,j++){ img.data[i]=rgba.data[i]; img.data[i+1]=rgba.data[i+1]; img.data[i+2]=rgba.data[i+2]; img.data[i+3]=guided[j]; }
      ctx.putImageData(img,0,0);
    }
    mMat.delete(); k3.delete(); k5.delete();

    const blob = await new Promise(r=> afterCanvas.toBlob(r,'image/png'));
    if(resultURL) URL.revokeObjectURL(resultURL);
    resultURL = URL.createObjectURL(blob);
    dlBtn.disabled = false;
    reveal();
    setStatusOk('Arrière-plan supprimé — ' + (ok?'GrabCut':'QuickMatte'));
  }

  /* ====== Image helpers ====== */
  function centralRect(iw,ih){
    const m = 0.18;
    return { x: Math.round(iw*m), y: Math.round(ih*m),
             w: Math.round(iw*(1-2*m)), h: Math.round(ih*(1-2*m)) };
  }
  function quickMatteFromBorder(srcCanvas){
    const W=srcCanvas.width, H=srcCanvas.height, ctx=srcCanvas.getContext('2d');
    const rgba=ctx.getImageData(0,0,W,H).data;
    const bw=Math.max(2, Math.floor(Math.min(W,H)*0.04));
    let r=0,g=0,b=0,n=0;
    for(let x=0;x<W;x++) for(let k=0;k<bw;k++){ let i=(k*W+x)*4; r+=rgba[i]; g+=rgba[i+1]; b+=rgba[i+2]; n++;
                                                  i=((H-1-k)*W+x)*4; r+=rgba[i]; g+=rgba[i+1]; b+=rgba[i+2]; n++; }
    for(let y=0;y<H;y++) for(let k=0;k<bw;k++){ let i=(y*W+k)*4; r+=rgba[i]; g+=rgba[i+1]; b+=rgba[i+2]; n++;
                                                  i=(y*W+(W-1-k))*4; r+=rgba[i]; g+=rgba[i+1]; b+=rgba[i+2]; n++; }
    r/=n; g/=n; b/=n;
    const dist=new Float32Array(W*H); let min=1e9,max=-1e9;
    for(let i=0,j=0;i<rgba.length;i+=4,j++){
      const d=(rgba[i]-r)**2+(rgba[i+1]-g)**2+(rgba[i+2]-b)**2;
      dist[j]=d; if(d<min)min=d; if(d>max)max=d;
    }
    const bins=256, hist=new Uint32Array(bins);
    for(let j=0;j<dist.length;j++){ const t=Math.floor((dist[j]-min)/(max-min+1e-6)*(bins-1)); hist[t]++; }
    let sum=0,sumB=0,wB=0,wF=0,mB=0,mF=0,maxVar=-1,th=0;
    for(let i=0;i<bins;i++) sum+=i*hist[i];
    const tot=W*H;
    for(let i=0;i<bins;i++){
      wB+=hist[i]; if(!wB) continue;
      wF=tot-wB; if(!wF) break;
      sumB+=i*hist[i]; mB=sumB/wB; mF=(sum-sumB)/wF;
      const between=wB*wF*(mB-mF)*(mB-mF);
      if(between>maxVar){ maxVar=between; th=i; }
    }
    const thr=min + (th/(bins-1))*(max-min);
    const alpha=new Uint8ClampedArray(W*H);
    for(let j=0;j<dist.length;j++) alpha[j] = dist[j]>thr ? 255 : 0;
    return alpha;
  }

  function guidedFilterAlpha(srcRGBA, alpha, w, h, radius=6, eps=1e-3){
    const N=(2*radius+1)*(2*radius+1);
    const I=new Float32Array(w*h);
    for(let i=0,j=0;i<srcRGBA.length;i+=4,j++) I[j]=(srcRGBA[i]*0.299+srcRGBA[i+1]*0.587+srcRGBA[i+2]*0.114)/255;
    const box=(inp)=>{
      const out=new Float32Array(w*h), tmp=new Float32Array(w*h);
      for(let y=0;y<h;y++){ let s=0; for(let x=0;x<w;x++){const i=y*w+x; s+=inp[i]; if(x>=2*radius) s-=inp[y*w+(x-2*radius-1)]; tmp[i]=s; } }
      for(let x=0;x<w;x++){ let s=0; for(let y=0;y<h;y++){const i=y*w+x; s+=tmp[i]; if(y>=2*radius) s-=tmp[(y-2*radius-1)*w+x]; out[i]=s/N; } }
      return out;
    };
    const A=new Float32Array(w*h); for(let i=0;i<w*h;i++) A[i]=alpha[i]/255;
    const I2=new Float32Array(w*h); for(let i=0;i<w*h;i++) I2[i]=I[i]*I[i];
    const IA=new Float32Array(w*h); for(let i=0;i<w*h;i++) IA[i]=I[i]*A[i];
    const meanI=box(I), meanI2=box(I2), meanA=box(A), meanIA=box(IA);
    const varI=new Float32Array(w*h), covIA=new Float32Array(w*h);
    for(let i=0;i<w*h;i++){ varI[i]=meanI2[i]-meanI[i]*meanI[i]; covIA[i]=meanIA[i]-meanI[i]*meanA[i]; }
    const a=new Float32Array(w*h), b=new Float32Array(w*h);
    for(let i=0;i<w*h;i++){ a[i]=covIA[i]/(varI[i]+eps); b[i]=meanA[i]-a[i]*meanI[i]; }
    const meanAcoef=box(a), meanBcoef=box(b);
    const out=new Uint8ClampedArray(w*h);
    for(let i=0;i<w*h;i++){ const v=meanAcoef[i]*I[i]+meanBcoef[i]; out[i]=Math.max(0,Math.min(255,Math.round(v*255))); }
    return out;
  }

  function reveal(){
    const dur=1100; handle.classList.add('show'); handle.style.opacity=1;
    function step(ts){ if(!step.t0) step.t0=ts; const p=Math.min(1,(ts-step.t0)/dur);
      const pct=100-(100*p); afterLayer.style.clipPath=`inset(0 0 0 ${pct}%)`; handle.style.left=`${pct}%`;
      if(p<1) requestAnimationFrame(step);
    } requestAnimationFrame(step);
  }

  function downloadImage(){
    if(!resultURL) return;
    const a=document.createElement('a');
    a.href=resultURL;
    a.download=(imageFile?.name?.replace(/\.[^.]+$/,'')||'image')+'_no-bg.png';
    a.click();
  }
  </script>
</body>
</html>
