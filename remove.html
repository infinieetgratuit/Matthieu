<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Infinie & gratuit — Supprimer l’arrière-plan</title>
  <meta name="color-scheme" content="dark"/>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">

  <!-- (laissé pour la forme, non utilisé) -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <!-- OpenCV.js (WASM) -->
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>

  <style>
    :root{ --bg:#0B0B0D; --panel:#0d1120; --text:#E6ECF7; --muted:#A4ADBD;
           --border:rgba(95,123,255,0.18); --accent1:#2FE3FF; --accent2:#1B4CFF; --ring:0 0 0 2px rgba(43,167,255,.35); }
    *{box-sizing:border-box} html,body{height:100%}
    body{ margin:0; font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background: radial-gradient(1200px 600px at 8% 12%, rgba(43,167,255,0.12), transparent 60%),
                  radial-gradient(1000px 800px at 82% 85%, rgba(27,76,255,0.10), transparent 55%), var(--bg);
      color:var(--text); }
    .container{max-width:1100px;margin:0 auto;padding:32px 20px 80px}
    .nav{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:24px}
    .brand{display:flex;align-items:center;gap:10px;font-weight:800;letter-spacing:.2px}
    .logo{width:28px;height:28px;border-radius:999px;background:radial-gradient(circle at 30% 30%,var(--accent1),var(--accent2));display:grid;place-items:center;color:#fff;font-weight:800}
    .badge{padding:6px 10px;font-size:12px;border-radius:999px;background:#0f1420;color:#9fb4ff;border:1px solid #1a2340}
    .title{font-size:42px;margin:6px 0 8px;line-height:1.1}
    .small{font-size:12px;color:var(--muted)}
    .grid{display:grid;gap:20px;grid-template-columns:1.1fr .9fr}
    @media (max-width:980px){.grid{grid-template-columns:1fr}}

    .panel{ background:linear-gradient(160deg, rgba(27,76,255,0.06), transparent),
                         linear-gradient(180deg, rgba(47,227,255,0.05), transparent 40%), var(--panel);
            border:1px solid var(--border); border-radius:16px; padding:18px;
            box-shadow:0 20px 60px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03); position:relative; }
    .dropzone{ position:relative; width:100%; aspect-ratio:16/10; display:grid; place-items:center;
      border:1.5px dashed #223054; border-radius:16px; background:#0a0f18; color:#93a6d3; overflow:hidden;
      transition:border-color .2s ease,box-shadow .2s ease,transform .2s ease; }
    .dropzone.drag{ border-color:#3a63ff; box-shadow:var(--ring); transform:scale(1.01) }
    .dropzone input{ position:absolute; inset:0; opacity:0; cursor:pointer }

    .preview{ position:relative; width:100%; aspect-ratio:16/10; border-radius:14px; overflow:hidden; background:#090f17; user-select:none }
    .preview img, .preview canvas{ position:absolute; inset:0; width:100%; height:100%; object-fit:contain }
    .afterLayer{ position:absolute; inset:0; background:url('texture.jpg'); background-size:24px 24px;
      clip-path: inset(0 0 0 100%); pointer-events:none; }
    .handle{ position:absolute; top:0; bottom:0; width:3px; left:100%; transform:translateX(-50%);
      background:linear-gradient(var(--accent1), var(--accent2)); box-shadow:0 0 0 1px rgba(255,255,255,.08);
      pointer-events:none; opacity:0; }
    .handle.show{ opacity:1; transition:opacity .25s ease }

    label{display:block;font-size:12px;color:var(--muted);margin-bottom:8px}
    .field{margin-bottom:16px}
    .toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .input, select{ width:100%; background:#0b0f1a; color:var(--text); border:1px solid #1a2340; border-radius:12px; padding:12px 14px; font-size:14px; outline:none; }
    .input:focus, select:focus{ box-shadow:var(--ring); border-color:#3a63ff }
    .btn{ background:#0b0f1a;border:1px solid #1a2340;color:var(--text); border-radius:12px;padding:12px 14px;font-size:14px;cursor:pointer;user-select:none;font-weight:700 }
    .btn:hover{ box-shadow:var(--ring); border-color:#3a63ff }
    .btn.primary{ background: linear-gradient(90deg, var(--accent1), var(--accent2)); border:none; color:white }
    .footer{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-top:16px;flex-wrap:wrap;color:var(--muted);font-size:12px}
    .badge-pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;font-size:12px;background:#0b0f1a;border:1px solid #1a2340;border-radius:999px}
    .progress{ width:64px;height:64px;border-radius:999px; background:radial-gradient(circle at 30% 30%, rgba(47,227,255,.25), rgba(27,76,255,.15));
      display:grid;place-items:center;position:absolute;bottom:16px;right:16px; box-shadow:0 10px 28px rgba(0,0,0,.45), inset 0 2px 8px rgba(255,255,255,.06) }
    .progress .ring{ width:48px;height:48px;border-radius:999px;border:3px solid rgba(255,255,255,.12); border-right-color:rgba(47,227,255,.9); animation:spin 1s linear infinite }
    @keyframes spin{ to{ transform:rotate(360deg) } }
    .hidden{display:none !important}
  </style>
</head>
<script type="module">
  import * as ort from "https://cdn.jsdelivr.net/npm/onnxruntime-web@1.21.0/+esm";
  import { removeBackground } from "https://cdn.jsdelivr.net/npm/@imgly/background-removal@1/+esm";

  // ⚠️ Remplace TA fonction runMatting existante par celle-ci (priorité IMG.LY, fallback ton algo si erreur)
  window.runMatting = async function () {
    try {
      setBusy(true);
      modeText.textContent = "Segmentation… (IMG.LY)";
      // on passe le File choisi par l’utilisateur (déjà dispo dans ton code → imageFile)
      const input = imageFile || (await (await fetch(imgBefore.src)).blob());
      const outBlob = await removeBackground(input);      // ← renvoie un PNG avec alpha
      const bmp = await createImageBitmap(outBlob);
      afterCanvas.width = bmp.width; 
      afterCanvas.height = bmp.height;
      afterCanvas.getContext("2d").drawImage(bmp, 0, 0);
      if (resultURL) URL.revokeObjectURL(resultURL);
      resultURL = URL.createObjectURL(outBlob);
      dlBtn.disabled = false;
      reveal();
      setStatusOk("Arrière-plan supprimé — IMG.LY");
    } catch (e) {
      console.warn("IMG.LY KO → fallback GrabCut", e);
      // si tu veux retomber sur ta version précédente :
      // await runMattingGrabCut();  // (renomme ton ancienne runMatting en runMattingGrabCut)
    } finally {
      setBusy(false);
    }
  };
</script>

<body>
  <div class="container">
    <div class="nav">
      <div class="brand"><div class="logo">∞</div> Infinie & gratuit</div>
      <span class="badge">Supprimer l’arrière-plan — 100% local</span>
    </div>

    <h1 class="title">Supprimer l’arrière-plan</h1>
    <p class="small">Détourage IA (MODNet + U²-Net, fallback WASM) — vos fichiers ne quittent jamais votre appareil.</p>

    <div class="grid">
      <div class="panel" id="panel-preview">
        <div class="dropzone" id="drop">
          <div style="text-align:center">
            <div style="font-size:18px;font-weight:800;margin-bottom:6px">Déposer une image</div>
            <div class="small">ou <u>Téléverser</u></div>
          </div>
          <input type="file" id="file" accept="image/*"/>
        </div>

        <div class="preview hidden" id="preview">
          <img id="imgBefore" alt="Avant"/>
          <div class="afterLayer" id="afterLayer"><canvas id="afterCanvas"></canvas></div>
          <div class="handle" id="handle"></div>
        </div>

        <div class="footer">
          <div class="badge-pill">
            <span id="modeDot" style="width:8px;height:8px;border-radius:99px;background:#3a3f54"></span>
            <span id="modeText">Chargement des modèles…</span>
          </div>
          <div id="fileInfo">Aucune image</div>
        </div>

        <div class="progress hidden" id="busy"><div class="ring"></div></div>
        <div class="small" style="margin-top:8px">Merci de nous faire confiance.</div>
      </div>

      <div class="panel">
        <div class="field">
          <label>Image</label>
          <div class="toolbar">
            <input class="input" type="file" id="file2" accept="image/*"/>
            <button class="btn" id="reset">Réinitialiser</button>
          </div>
        </div>

        <div class="field">
          <label>Qualité</label>
          <select class="input" id="quality">
            <option value="medium" selected>Moyenne (rapide)</option>
            <option value="high">Haute (originale)</option>
          </select>
        </div>

        <div class="field">
          <label>Exporter</label>
          <div class="toolbar">
            <button class="btn" id="run" disabled>Lancer</button>
            <button class="btn primary" id="download" disabled>Télécharger PNG</button>
          </div>
        </div>

        <p class="small" style="margin-top:10px">“Moyenne” réduit la taille pour aller plus vite. “Haute” garde la résolution originale. La texture n’est qu’un aperçu.</p>
      </div>
    </div>
  </div>

<script>
/* ====== CONFIG ====== */
const MEDIUM_MAX = 1600;

/* ====== DOM ====== */
const runBtn = document.getElementById('run');
const resetBtn = document.getElementById('reset');
const dlBtn = document.getElementById('download');
const qualitySel = document.getElementById('quality');
const busy = document.getElementById('busy');
const modeText = document.getElementById('modeText');
const modeDot = document.getElementById('modeDot');
const file = document.getElementById('file');
const file2 = document.getElementById('file2');
const drop = document.getElementById('drop');
const preview = document.getElementById('preview');
const imgBefore = document.getElementById('imgBefore');
const afterCanvas = document.getElementById('afterCanvas');
const afterLayer = document.getElementById('afterLayer');
const handle = document.getElementById('handle');
const fileInfo = document.getElementById('fileInfo');

let imageFile=null, imgReady=false, cvReady=false, resultURL=null;
let roi=null, roiCanvas=null, roiCtx=null, dragging=false, startPt=null;

function setBusy(v){ busy.classList.toggle('hidden', !v); }
function updateRun(){ runBtn.disabled = !(imgReady && cvReady); }
function setStatusOk(txt){ modeText.textContent=txt; modeDot.style.background='linear-gradient(90deg, var(--accent1), var(--accent2))'; }
function setStatusErr(txt){ modeText.textContent='⚠️ '+txt; modeDot.style.background='#9b2c2c'; }

/* ====== Attente OpenCV (vraiment prêt) ====== */
(function waitForCV(){
  function ready(){ cvReady=true; setStatusOk('MODNet prêt'); updateRun(); }
  const check = () => {
    if (window.cv) {
      if (cv.ready && typeof cv.ready.then === 'function') { cv.ready.then(ready); }
      else if ('onRuntimeInitialized' in cv) { cv.onRuntimeInitialized = ready; }
      else { // build sans promesse
        const t=setInterval(()=>{try{new cv.Mat(); clearInterval(t); ready();}catch{}},60);
      }
      return true;
    }
    return false;
  };
  if (!check()){
    const t=setInterval(()=>{ if(check()) clearInterval(t); },80);
  }
})();

/* ====== Overlay ROI (rectangle) ====== */
function ensureRoiCanvas(){
  if (roiCanvas) return;
  roiCanvas = document.createElement('canvas');
  roiCanvas.style.position='absolute';
  roiCanvas.style.inset='0';
  roiCanvas.style.pointerEvents='auto';
  preview.appendChild(roiCanvas);
  roiCtx = roiCanvas.getContext('2d');
  resizeRoiCanvas();
  window.addEventListener('resize', resizeRoiCanvas);
  roiCanvas.addEventListener('mousedown', onDown);
  roiCanvas.addEventListener('mousemove', onMove);
  window.addEventListener('mouseup', onUp);
}
function resizeRoiCanvas(){
  if(!roiCanvas) return;
  const r = preview.getBoundingClientRect();
  roiCanvas.width = Math.round(r.width);
  roiCanvas.height= Math.round(r.height);
  drawRoi();
}
function drawRoi(){
  if(!roiCtx) return;
  roiCtx.clearRect(0,0,roiCanvas.width,roiCanvas.height);
  if(!roi) return;
  roiCtx.lineWidth = 2;
  roiCtx.setLineDash([6,4]);
  roiCtx.strokeStyle = '#2FE3FF';
  const rect = imgRectToCanvas(roi);
  roiCtx.strokeRect(rect.x, rect.y, rect.w, rect.h);
}
function onDown(e){
  if(!imgReady) return;
  const p = toImageCoords(e.offsetX, e.offsetY);
  if(!p) return;
  dragging=true; startPt=p; roi={x:p.x,y:p.y,w:0,h:0}; drawRoi();
}
function onMove(e){
  if(!dragging || !startPt) return;
  const p = toImageCoords(e.offsetX, e.offsetY); if(!p) return;
  roi = { x: Math.min(startPt.x,p.x), y: Math.min(startPt.y,p.y),
          w: Math.abs(p.x-startPt.x), h: Math.abs(p.y-startPt.y) };
  drawRoi();
}
function onUp(){ dragging=false; startPt=null; drawRoi(); }

function toImageCoords(px,py){
  const cw = roiCanvas.width, ch = roiCanvas.height;
  const iw = imgBefore.naturalWidth, ih = imgBefore.naturalHeight;
  if(!iw||!ih) return null;
  const s = Math.min(cw/iw, ch/ih);
  const wd = Math.round(iw*s), hd = Math.round(ih*s);
  const ox = Math.floor((cw-wd)/2), oy = Math.floor((ch-hd)/2);
  if(px<ox||py<oy||px>ox+wd||py>oy+hd) return null;
  return { x: Math.max(0, Math.min(iw-1, Math.round((px-ox)/s))),
           y: Math.max(0, Math.min(ih-1, Math.round((py-oy)/s))) };
}
function imgRectToCanvas(r){
  const cw = roiCanvas.width, ch = roiCanvas.height;
  const iw = imgBefore.naturalWidth, ih = imgBefore.naturalHeight;
  const s = Math.min(cw/iw, ch/ih);
  const wd = Math.round(iw*s), hd = Math.round(ih*s);
  const ox = Math.floor((cw-wd)/2), oy = Math.floor((ch-hd)/2);
  return { x: Math.round(ox + r.x*s), y: Math.round(oy + r.y*s),
           w: Math.round(r.w*s), h: Math.round(r.h*s) };
}

/* ====== LISTENERS ====== */
['dragover','dragleave','drop'].forEach(ev=>{
  drop.addEventListener(ev, e=>{
    if(ev==='dragover'){ e.preventDefault(); drop.classList.add('drag'); }
    if(ev==='dragleave'){ drop.classList.remove('drag'); }
    if(ev==='drop'){ e.preventDefault(); drop.classList.remove('drag'); onFile(e.dataTransfer.files?.[0]); }
  });
});
file.addEventListener('change', e=> onFile(e.target.files?.[0]));
file2.addEventListener('change', e=> onFile(e.target.files?.[0]));
resetBtn.addEventListener('click', resetAll);
runBtn.addEventListener('click', ()=>{ if(runBtn.disabled){ setStatusErr('Choisis une image'); return; } runMatting(); });
dlBtn.addEventListener('click', downloadImage);

function resetAll(){
  imageFile=null; imgReady=false; updateRun();
  if(resultURL){ URL.revokeObjectURL(resultURL); resultURL=null; }
  imgBefore.removeAttribute('src');
  afterCanvas.getContext('2d').clearRect(0,0,afterCanvas.width,afterCanvas.height);
  preview.classList.add('hidden'); drop.classList.remove('hidden');
  dlBtn.disabled = true;
  afterLayer.style.clipPath='inset(0 0 0 100%)'; handle.style.left='100%'; handle.style.opacity=0; handle.classList.remove('show');
  fileInfo.textContent='Aucune image';
  roi=null; drawRoi?.();
}
async function onFile(f){
  if(!f) return;
  imageFile=f;
  const url=URL.createObjectURL(f);
  imgBefore.src=url;
  imgBefore.onload=()=>{
    afterCanvas.width=imgBefore.naturalWidth||imgBefore.width;
    afterCanvas.height=imgBefore.naturalHeight||imgBefore.height;
    imgReady=true; ensureRoiCanvas(); updateRun();
  };
  fileInfo.textContent=(f.size/1e6).toFixed(2)+' MB';
  drop.classList.add('hidden'); preview.classList.remove('hidden');
  dlBtn.disabled=true;
  afterLayer.style.clipPath='inset(0 0 0 100%)'; handle.style.left='100%'; handle.style.opacity=0;
}

/* ====== Outils ====== */
function centralRect(iw,ih){
  const m = 0.18;
  return { x: Math.round(iw*m), y: Math.round(ih*m),
           w: Math.round(iw*(1-2*m)), h: Math.round(ih*(1-2*m)) };
}
function guidedFilterAlpha(srcRGBA, alpha, w, h, radius=6, eps=1e-3){
  const N=(2*radius+1)*(2*radius+1);
  const I=new Float32Array(w*h);
  for(let i=0,j=0;i<srcRGBA.length;i+=4,j++) I[j]=(srcRGBA[i]*0.299+srcRGBA[i+1]*0.587+srcRGBA[i+2]*0.114)/255;
  const box=(inp)=>{
    const out=new Float32Array(w*h), tmp=new Float32Array(w*h);
    for(let y=0;y<h;y++){ let s=0; for(let x=0;x<w;x++){const i=y*w+x; s+=inp[i]; if(x>=2*radius) s-=inp[y*w+(x-2*radius-1)]; tmp[i]=s; } }
    for(let x=0;x<w;x++){ let s=0; for(let y=0;y<h;y++){const i=y*w+x; s+=tmp[i]; if(y>=2*radius) s-=tmp[(y-2*radius-1)*w+x]; out[i]=s/N; } }
    return out;
  };
  const A=new Float32Array(w*h); for(let i=0;i<w*h;i++) A[i]=alpha[i]/255;
  const I2=new Float32Array(w*h); for(let i=0;i<w*h;i++) I2[i]=I[i]*I[i];
  const IA=new Float32Array(w*h); for(let i=0;i<w*h;i++) IA[i]=I[i]*A[i];
  const meanI=box(I), meanI2=box(I2), meanA=box(A), meanIA=box(IA);
  const varI=new Float32Array(w*h), covIA=new Float32Array(w*h);
  for(let i=0;i<w*h;i++){ varI[i]=meanI2[i]-meanI[i]*meanI[i]; covIA[i]=meanIA[i]-meanI[i]*meanA[i]; }
  const a=new Float32Array(w*h), b=new Float32Array(w*h);
  for(let i=0;i<w*h;i++){ a[i]=covIA[i]/(varI[i]+eps); b[i]=meanA[i]-a[i]*meanI[i]; }
  const meanAcoef=box(a), meanBcoef=box(b);
  const out=new Uint8ClampedArray(w*h);
  for(let i=0;i<w*h;i++){ const v=meanAcoef[i]*I[i]+meanBcoef[i]; out[i]=Math.max(0,Math.min(255,Math.round(v*255))); }
  return out;
}

/* ====== Fallback sans GrabCut : QuickMatte (couleur de bord + Otsu) ====== */
function quickMatteFromBorder(srcCanvas){
  const W=srcCanvas.width, H=srcCanvas.height, ctx=srcCanvas.getContext('2d');
  const rgba=ctx.getImageData(0,0,W,H).data;
  const bw=Math.max(2, Math.floor(Math.min(W,H)*0.04));
  let r=0,g=0,b=0,n=0;
  // moyenne couleur bord
  for(let x=0;x<W;x++) for(let k=0;k<bw;k++){ let i=(k*W+x)*4; r+=rgba[i]; g+=rgba[i+1]; b+=rgba[i+2]; n++;
                                                i=((H-1-k)*W+x)*4; r+=rgba[i]; g+=rgba[i+1]; b+=rgba[i+2]; n++; }
  for(let y=0;y<H;y++) for(let k=0;k<bw;k++){ let i=(y*W+k)*4; r+=rgba[i]; g+=rgba[i+1]; b+=rgba[i+2]; n++;
                                                i=(y*W+(W-1-k))*4; r+=rgba[i]; g+=rgba[i+1]; b+=rgba[i+2]; n++; }
  r/=n; g/=n; b/=n;
  // distance euclidienne à la couleur de bord
  const dist=new Float32Array(W*H); let min=1e9,max=-1e9;
  for(let i=0,j=0;i<rgba.length;i+=4,j++){
    const d=(rgba[i]-r)**2+(rgba[i+1]-g)**2+(rgba[i+2]-b)**2;
    dist[j]=d; if(d<min)min=d; if(d>max)max=d;
  }
  // histo 256 bins + Otsu
  const bins=256, hist=new Uint32Array(bins);
  for(let j=0;j<dist.length;j++){ const t=Math.floor((dist[j]-min)/(max-min+1e-6)*(bins-1)); hist[t]++; }
  let sum=0,sumB=0,wB=0,wF=0,mB=0,mF=0,maxVar=-1,th=0;
  for(let i=0;i<bins;i++) sum+=i*hist[i];
  let tot=srcCanvas.width*srcCanvas.height;
  for(let i=0;i<bins;i++){
    wB+=hist[i]; if(!wB) continue;
    wF=tot-wB; if(!wF) break;
    sumB+=i*hist[i]; mB=sumB/wB; mF=(sum-sumB)/wF;
    const between=wB*wF*(mB-mF)*(mB-mF);
    if(between>maxVar){ maxVar=between; th=i; }
  }
  const thr=min + (th/(bins-1))*(max-min);
  const alpha=new Uint8ClampedArray(W*H);
  for(let j=0;j<dist.length;j++) alpha[j] = dist[j]>thr ? 255 : 0; // sujet plus "loin" de la couleur de fond
  return alpha;
}

/* ====== Détourage : GrabCut robuste + fallbacks ====== */
async function runMatting(){
  try{
    setBusy(true);
    modeText.textContent='Préparation…';
    await imgBefore.decode?.();

    const W0=imgBefore.naturalWidth, H0=imgBefore.naturalHeight;
    const high=(qualitySel.value==='high');
    const targetMax=high?Math.max(W0,H0):MEDIUM_MAX;
    const scale=Math.min(1, targetMax/Math.max(W0,H0));
    const W=Math.round(W0*scale), H=Math.round(H0*scale);

    const src=document.createElement('canvas'); src.width=W; src.height=H;
    src.getContext('2d').drawImage(imgBefore,0,0,W,H);

    let R = roi ? { x: Math.round(roi.x*scale), y: Math.round(roi.y*scale),
                    w: Math.round(roi.w*scale), h: Math.round(roi.h*scale) }
                : centralRect(W,H);
    if(R.w<12||R.h<12) R = centralRect(W,H);

    // ===== GrabCut =====
    let alpha=null, ok=false;
    try{
      const srcMat = cv.imread(src);
      const bgr = new cv.Mat(); cv.cvtColor(srcMat, bgr, cv.COLOR_RGBA2BGR);
      const smooth=new cv.Mat(); cv.bilateralFilter(bgr, smooth, 9, 75, 75);
      const mask=cv.Mat.zeros(H,W,cv.CV_8U), bgd=new cv.Mat(), fgd=new cv.Mat();

      modeText.textContent='Segmentation… (GrabCut)';
      cv.grabCut(smooth, mask, new cv.Rect(R.x,R.y,R.w,R.h), bgd, fgd, 5, cv.GC_INIT_WITH_RECT);

      alpha=new Uint8ClampedArray(W*H);
      let sumA=0;
      for(let i=0;i<mask.data.length;i++){
        const v=mask.data[i]; const a=(v===cv.GC_FGD||v===cv.GC_PR_FGD)?255:0;
        alpha[i]=a; sumA+=a;
      }

      // si trop peu de FG, on élargit le rectangle et on retente une fois
      if(sumA < W*H*0.005){
        const grow=0.12;
        const Rx = Math.max(0, Math.round(R.x - R.w*grow));
        const Ry = Math.max(0, Math.round(R.y - R.h*grow));
        const Rw = Math.min(W-Rx, Math.round(R.w*(1+2*grow)));
        const Rh = Math.min(H-Ry, Math.round(R.h*(1+2*grow)));
        mask.setTo(new cv.Scalar(0));
        cv.grabCut(smooth, mask, new cv.Rect(Rx,Ry,Rw,Rh), bgd, fgd, 5, cv.GC_INIT_WITH_RECT);
        sumA=0;
        for(let i=0;i<mask.data.length;i++){ const v=mask.data[i]; const a=(v===cv.GC_FGD||v===cv.GC_PR_FGD)?255:0; alpha[i]=a; sumA+=a; }
      }

      srcMat.delete(); bgr.delete(); smooth.delete(); mask.delete(); bgd.delete(); fgd.delete();

      if(sumA >= W*H*0.002) ok=true;
    }catch(e){ console.warn('GrabCut KO:', e); }

    // ===== Fallback QuickMatte si nécessaire =====
    if(!ok){
      modeText.textContent='Estimation rapide…';
      alpha = quickMatteFromBorder(src);
    }

    // ===== Post-process & composition =====
    const mMat = cv.matFromArray(H,W,cv.CV_8U, alpha);
    const k3 = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3,3));
    const k5 = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5,5));
    cv.morphologyEx(mMat, mMat, cv.MORPH_OPEN, k3);
    cv.morphologyEx(mMat, mMat, cv.MORPH_CLOSE, k5);
    cv.GaussianBlur(mMat, mMat, new cv.Size(3,3), 0);

    const rgba = src.getContext('2d').getImageData(0,0,W,H);
    const guided = guidedFilterAlpha(rgba.data, mMat.data, W,H, 8, 1e-3);

    if(high && scale<1){
      const tmp=document.createElement('canvas'); tmp.width=W; tmp.height=H;
      const tctx=tmp.getContext('2d'); const img=tctx.createImageData(W,H);
      for(let i=0,j=0;i<img.data.length;i+=4,j++){ img.data[i]=rgba.data[i]; img.data[i+1]=rgba.data[i+1]; img.data[i+2]=rgba.data[i+2]; img.data[i+3]=guided[j]; }
      tctx.putImageData(img,0,0);
      afterCanvas.width=W0; afterCanvas.height=H0;
      const ctx=afterCanvas.getContext('2d'); ctx.imageSmoothingEnabled=true;
      ctx.drawImage(tmp,0,0,W,H,0,0,W0,H0);
    }else{
      afterCanvas.width=W; afterCanvas.height=H;
      const ctx=afterCanvas.getContext('2d'); const img=ctx.createImageData(W,H);
      for(let i=0,j=0;i<img.data.length;i+=4,j++){ img.data[i]=rgba.data[i]; img.data[i+1]=rgba.data[i+1]; img.data[i+2]=rgba.data[i+2]; img.data[i+3]=guided[j]; }
      ctx.putImageData(img,0,0);
    }
    mMat.delete(); k3.delete(); k5.delete();

    const blob = await new Promise(r=> afterCanvas.toBlob(r,'image/png'));
    if(resultURL) URL.revokeObjectURL(resultURL);
    resultURL = URL.createObjectURL(blob);
    dlBtn.disabled=false; reveal();
    setStatusOk('Arrière-plan supprimé — ' + (ok?'GrabCut':'QuickMatte'));
  }catch(err){
    console.error(err);
    setStatusErr(err?.message || String(err));
  }finally{
    setBusy(false);
  }
}

/* ====== Animation & download ====== */
function reveal(){
  const dur=1100; handle.classList.add('show'); handle.style.opacity=1;
  function step(ts){ if(!step.t0) step.t0=ts; const p=Math.min(1,(ts-step.t0)/dur);
    const pct=100-(100*p); afterLayer.style.clipPath=`inset(0 0 0 ${pct}%)`; handle.style.left=`${pct}%`;
    if(p<1) requestAnimationFrame(step);
  } requestAnimationFrame(step);
}
function downloadImage(){
  if(!resultURL) return;
  const a=document.createElement('a');
  a.href=resultURL;
  a.download=(imageFile?.name?.replace(/\.[^.]+$/,'')||'image')+'_no-bg.png';
  a.click();
}
</script>
</body>
</html>



