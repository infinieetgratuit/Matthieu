<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Infinie & gratuit ‚Äî Studio Express ‚Äî Easy V3</title>
<meta name="color-scheme" content="dark"/>
<link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<!-- Polices (display=swap pour vitesse). On garde un set utile + ‚Äú3D/display‚Äù -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Poppins:wght@600&family=Montserrat:wght@600&family=Space+Grotesk:wght@600&family=Bebas+Neue&family=Playfair+Display:wght@700&family=DM+Serif+Display&family=Exo+2:wght@700&family=Kanit:wght@700&family=Anton&family=Roboto+Mono:wght@700&family=Bungee&family=Bungee+Shade&family=Tilt+Prism&family=Monoton&family=Rampart+One&family=Alfa+Slab+One&family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#0B0B0D; --panel:#0d1120; --text:#E6ECF7; --muted:#A4ADBD;
  --border:rgba(95,123,255,0.18); --accent1:#2FE3FF; --accent2:#1B4CFF; --ring:0 0 0 2px rgba(43,167,255,.35);
}
*{box-sizing:border-box} html,body{height:100%}
body{
  margin:0; font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,Arial;
  background:
    radial-gradient(1100px 600px at 8% 12%, rgba(43,167,255,0.12), transparent 60%),
    radial-gradient(1000px 800px at 82% 85%, rgba(27,76,255,0.10), transparent 55%),
    var(--bg);
  color:var(--text);
}
.container{max-width:1100px;margin:0 auto;padding:22px 14px 60px}
.nav{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
.brand{display:flex;align-items:center;gap:10px;font-weight:800}
.logo{width:26px;height:26px;border-radius:999px;background:radial-gradient(circle at 30% 30%,var(--accent1),var(--accent2));display:grid;place-items:center;color:#fff}
.badge{padding:6px 10px;font-size:12px;border-radius:999px;background:#0f1420;color:#9fb4ff;border:1px solid #1a2340}
.title{font-size:28px;margin:4px 0 2px}
.small{font-size:12px;color:var(--muted)}

.grid{display:grid;grid-template-columns:1fr 270px;gap:12px}
@media (max-width:980px){.grid{grid-template-columns:1fr}}

.panel{
  background:linear-gradient(160deg, rgba(27,76,255,0.06), transparent),
             linear-gradient(180deg, rgba(47,227,255,0.05), transparent 40%), var(--panel);
  border:1px solid var(--border); border-radius:14px; padding:12px;
  box-shadow:0 18px 50px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
}

/* Stage : cadre 16:9 FIXE (ne bouge jamais) */
.stage{
  border:1px dashed #223054; border-radius:12px; padding:10px; position:relative;
  background:
   conic-gradient(#0c111a 0 25%, #0c111a 0) padding-box,
   repeating-conic-gradient(#0e1420 0 25%, #0e1420 0 50%, #0b101a 0 75%, #0b101a 0 100%) 0/22px 22px;
}
.host{position:relative; width:100%; aspect-ratio:16/9; border-radius:10px; overflow:hidden; display:grid;place-items:center}
#canvas{max-width:100%;max-height:100%;display:block;background:transparent;transform-origin:center center}

/* Masque de cadrage (assombrit l'ext√©rieur, cadre centr√©) */
#guide{position:absolute; inset:0; pointer-events:none}

/* Toolbar */
.toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
.btn,.input,select{
  background:#0b0f1a;border:1px solid #1a2340;color:var(--text);border-radius:10px;padding:9px 12px;font-size:13px;outline:none
}
.btn{cursor:pointer;font-weight:800}
.btn:hover,.input:focus,select:focus{ box-shadow:var(--ring); border-color:#3a63ff }
.btn.primary{background:linear-gradient(90deg,var(--accent1),var(--accent2));border:none;color:#fff}
label.switch{display:flex;gap:8px;align-items:center}

/* Layers */
.side .head{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
.layers{display:flex;flex-direction:column;gap:6px;max-height:520px;overflow:auto}
.item{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;padding:8px;border:1px solid #1a2340;background:#0b0f1a;border-radius:9px}
.item.active{outline:2px solid rgba(47,227,255,.35)}
.mini{width:28px;height:28px;border-radius:8px;border:1px solid #1a2340;background:#0c1220;color:#dfe8ff;display:grid;place-items:center;cursor:pointer}
.mini:hover{box-shadow:var(--ring);border-color:#3a63ff}
.mini svg{width:16px;height:16px;stroke:currentColor;fill:none;stroke-width:2}
.mini.vis{color:#9fb4ff}
.mini.up{color:var(--accent1)}
.mini.down{color:var(--accent2)}
.mini.del{color:#FF5C5C}
.typeico svg{width:18px;height:18px;stroke:#cfe1ff;fill:none;stroke-width:2}

/* Slider d‚Äôopacit√© */
.op-wrap{margin-top:6px}
input[type="range"].op{width:100%; accent-color: var(--accent1);}

/* S√©lection + rotation */
#handles.hidden{display:none}
.handle{position:absolute;width:16px;height:16px;border-radius:3px;background:#fff;border:2px solid #1b4cff;box-shadow:0 0 0 3px rgba(27,76,255,.22)}
.handle[data-k="tl"],.handle[data-k="br"]{cursor:nwse-resize}
.handle[data-k="tr"],.handle[data-k="bl"]{cursor:nesw-resize}
.outline{position:absolute;border:2px solid #1b4cff;box-shadow:0 0 0 3px rgba(27,76,255,.22);border-radius:6px;pointer-events:none;transform-origin:center center}
.rot{position:absolute;width:14px;height:14px;border-radius:50%;background:#1b4cff;border:2px solid #fff;box-shadow:0 0 0 3px rgba(27,76,255,.22);cursor:grab}
.rotline{position:absolute;width:2px;background:#1b4cff}

.palette{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
.sw{width:18px;height:18px;border-radius:4px;border:1px solid #1a2340;cursor:pointer}
.hint{font-size:12px;color:#9fb4ff;margin-top:8px}

/* --- BANQUE D'IMAGES (ajout) --- */
.stock{margin-top:10px;border:1px solid var(--border);background:#0b0f1a;border-radius:12px;padding:10px}
.stock .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
.stock .row .input{min-width:220px}
.stock-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:8px}
.thumb{position:relative;border:1px solid #1a2340;border-radius:10px;overflow:hidden;background:#0c1220;cursor:pointer}
.thumb img{width:100%;height:100%;aspect-ratio:1/1;object-fit:cover;display:block}
.thumb .cap{position:absolute;left:6px;right:6px;bottom:6px;font-size:11px;color:#cfe1ff;background:rgba(0,0,0,.42);padding:4px 6px;border-radius:6px;backdrop-filter:blur(3px);display:none}
.thumb:hover .cap{display:block}
.stock .foot{display:flex;gap:8px;align-items:center;justify-content:flex-end;margin-top:8px}

/* --- PANEL STICKERS (r√©utilise les styles .stock) --- */
.stickers{margin-top:10px;border:1px solid var(--border);background:#0b0f1a;border-radius:12px;padding:10px}
.stickers .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
</style>
</head>
<body>
<div class="container">
  <div class="nav">
    <div class="brand"><div class="logo">‚àû</div> Infinie & gratuit</div>
    <span class="badge">Studio Express ‚Äî Easy V3</span>
  </div>

  <h1 class="title">Studio Express ‚Äî Easy</h1>
  <p class="small">Importer, d√©placer, agrandir (coins bleus), rotation, texte (polices rapides), blocs couleur, calques, export PNG multi-formats (toile au bon ratio) et fond transparent.</p>

  <div class="grid">
    <!-- CENTRE -->
    <div class="panel">
      <div class="toolbar">
        <button class="btn primary" id="btnAddImg">+ Image</button>
        <input id="file" type="file" accept="image/*" multiple style="display:none">
        <button class="btn" id="btnAddText">+ Texte</button>
        <button class="btn" id="btnAddRect">+ Bloc</button>
        <!-- STICKERS (GitHub repo) -->
        <button class="btn" id="btnStickers">Stickers</button>
        <label class="switch"><input id="bgTransparent" type="checkbox" checked><span>Fond transparent</span></label>
        <select class="input" id="fmt">
          <option value="169" selected>16:9 ‚Äî 1920√ó1080</option>
          <option value="916">9:16 ‚Äî 1080√ó1920</option>
          <option value="11">1:1 ‚Äî 1080√ó1080</option>
          <option value="yt">Miniature YouTube ‚Äî 1280√ó720</option>
        </select>
        <button class="btn" id="btnExport">Exporter PNG</button>
      </div>

      <div class="stage">
        <div class="host" id="host">
          <canvas id="canvas" width="1920" height="1080"></canvas>

          <!-- Masque de cadrage (assombrit l'ext√©rieur de la zone d'export) -->
          <canvas id="guide"></canvas>

          <div id="outline" class="outline" style="display:none"></div>
          <div id="handles" class="hidden">
            <div class="handle" data-k="tl" title="Agrandir/R√©duire"></div>
            <div class="handle" data-k="tr" title="Agrandir/R√©duire"></div>
            <div class="handle" data-k="bl" title="Agrandir/R√©duire"></div>
            <div class="handle" data-k="br" title="Agrandir/R√©duire"></div>
            <div class="rotline" id="rotline" style="display:none;height:28px"></div>
            <div class="rot" id="rothandle" title="Rotation" style="display:none"></div>
          </div>
        </div>
      </div>

      <!-- üí† BANQUE D'IMAGES : Pexels (cl√© int√©gr√©e) -->
      <div class="stock" id="stock">
        <div class="row">
          <input id="stockQuery" class="input" placeholder="Rechercher des images‚Ä¶ (ex: cyberpunk, cat, city)"/>
          <button class="btn" id="stockSearch">Rechercher</button>
        </div>
        <div class="stock-grid" id="stockGrid" aria-live="polite"></div>
        <div class="foot">
          <button class="btn" id="stockMore" style="display:none">Charger plus</button>
        </div>
        <div class="small">Astuce : clique une vignette pour l‚Äôajouter comme calque dans la sc√®ne.</div>
      </div>
      <!-- /BANQUE D'IMAGES -->

      <!-- üß© STICKERS : banque GitHub -->
      <div class="stickers" id="stickersPanel" style="display:none">
        <div class="row" style="gap:10px">
          <div class="small">Stickers depuis <b>GitHub</b> : <code>infinieetgratuit/stickers</code></div>
          <a class="btn" id="openStickersGitHub" href="https://github.com/infinieetgratuit/stickers" target="_blank" rel="noopener" style="margin-left:auto">Ouvrir dans GitHub</a>
        </div>
        <div class="stock-grid" id="stickersGrid"></div>
        <div class="small" id="stickersHint">Clique un sticker pour l‚Äôajouter comme calque.</div>
      </div>
      <!-- /STICKERS -->

      <div class="hint">Astuce : <b>clique & glisse</b> pour d√©placer ‚Ä¢ <b>coins bleus</b> pour agrandir (ratio conserv√©) ‚Ä¢ poign√©e ronde = <b>rotation</b> ‚Ä¢ <b>Suppr</b> pour enlever ‚Ä¢ Fl√®ches = ajustement fin ‚Ä¢ <b>Alt + molette</b> = zoom aper√ßu</div>
    </div>

    <!-- DROITE (calques + texte/bloc) -->
    <div class="panel side">
      <div class="head">
        <div class="small">Calques</div>
        <div class="small" id="count">0</div>
      </div>
      <div id="layers" class="layers"></div>

      <div class="small" style="margin:8px 0 6px">Texte / Bloc (si s√©lectionn√©)</div>
      <div class="item" style="grid-template-columns:1fr">
        <input class="input" id="tContent" placeholder="Votre texte‚Ä¶"/>
        <select class="input" id="tFont" style="margin-top:6px">
          <option>Inter</option><option>Poppins</option><option>Montserrat</option>
          <option>Space Grotesk</option><option>Playfair Display</option><option>DM Serif Display</option>
          <option>Exo 2</option><option>Kanit</option><option>Anton</option>
          <option>Roboto Mono</option>
          <!-- Display / ‚Äú3D-like‚Äù -->
          <option>Bungee</option><option>Bungee Shade</option><option>Tilt Prism</option>
          <option>Monoton</option><option>Rampart One</option><option>Alfa Slab One</option>
          <option>Press Start 2P</option>
        </select>
        <div style="display:flex;gap:6px;margin-top:6px;align-items:center">
          <input class="input" id="tSize" type="number" value="72" min="8" max="400" style="width:90px">
          <input class="input" id="tColor" type="color" value="#E6ECF7" style="padding:0 6px;width:48px">
          <label class="switch" style="margin-left:auto"><input id="tBold" type="checkbox"><span>Gras</span></label>
        </div>
        <div class="palette" id="colorPal"></div>
      </div>
    </div>
  </div>
</div>

<script>
/* ============ SVG ICONES (remplace les emojis) ============ */
const ico = {
  eye: () => `<svg viewBox="0 0 24 24"><ellipse cx="12" cy="12" rx="9" ry="6"/><circle cx="12" cy="12" r="3"/></svg>`,
  eyeOff: () => `<svg viewBox="0 0 24 24"><ellipse cx="12" cy="12" rx="9" ry="6"/><circle cx="12" cy="12" r="3"/><line x1="3" y1="3" x2="21" y2="21"/></svg>`,
  up: () => `<svg viewBox="0 0 24 24"><polyline points="6 15 12 9 18 15"/></svg>`,
  down: () => `<svg viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"/></svg>`,
  trash: () => `<svg viewBox="0 0 24 24"><polyline points="3 6 21 6"/><path d="M5 6l1 14h12l1-14"/><path d="M9 6V4h6v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>`,
  typeImg: () => `<svg viewBox="0 0 24 24"><rect x="3" y="5" width="18" height="14" rx="2"/><path d="M7 14l4-4 6 6"/><circle cx="8.5" cy="9" r="1"/></svg>`,
  typeRect: () => `<svg viewBox="0 0 24 24"><rect x="4" y="6" width="16" height="12" rx="2"/></svg>`,
  typeText: () => `<svg viewBox="0 0 24 24"><line x1="4" y1="6" x2="20" y2="6"/><line x1="12" y1="6" x2="12" y2="20"/></svg>`
};

/* ============ √âtat & utilitaires ============ */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const host = document.getElementById('host');
const guide = document.getElementById('guide');
const outline = document.getElementById('outline');
const handles = document.getElementById('handles');
const rotline = document.getElementById('rotline');
const rothandle = document.getElementById('rothandle');
const hNodes = [...handles.querySelectorAll('.handle')];
let layers = [];        // back -> front
let selected = null;    // id
let dragging = null;    // {mode:'move'|'scale'|'rotate', ...}
let transparent = true;

/* Zoom d'aper√ßu (cadre centr√©, ne bouge pas) */
let viewScale = 1;

const uid = () => Math.random().toString(36).slice(2,9);
const clamp = (v,a,b)=> v<a?a : v>b?b : v;

/* Ratio d'export courant (cadre visuel) */
let exportFmt = '169';
let exportAspect = 16/9; // par d√©faut

function rectCanvas(){ return canvas.getBoundingClientRect(); }
function rectHost(){ return host.getBoundingClientRect(); }
function clientToWorld(cx, cy){
  const rc = rectCanvas();
  return { x: (cx - rc.left) * (canvas.width  / rc.width),
           y: (cy - rc.top ) * (canvas.height / rc.height) };
}
function worldToHost(wx, wy){
  const rc = rectCanvas(), rh = rectHost();
  const sx = rc.width / canvas.width, sy = rc.height / canvas.height;
  return { x: (wx * sx) + (rc.left - rh.left), y: (wy * sy) + (rc.top - rh.top) };
}
function rot2D(x,y,a){ const c=Math.cos(a), s=Math.sin(a); return {x:x*c - y*s, y:x*s + y*c}; }
function fontCSS(name){ return name.includes(' ')? `"${name}"` : name; }

/* ============ Rendu (avec rotation + text cache) ============ */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(const L of layers){
    if(!L.visible) continue;
    ctx.save();
    const cx = L.x + L.w/2, cy = L.y + L.h/2;
    ctx.translate(cx, cy); ctx.rotate(L.rot||0);
    ctx.globalAlpha = (L.opacity ?? 1);
    if(L.type==='image'){
      ctx.drawImage(L.img, -L.w/2, -L.h/2, L.w, L.h);
    } else if(L.type==='rect'){
      ctx.fillStyle = L.fill || '#888';
      ctx.fillRect(-L.w/2, -L.h/2, L.w, L.h);
    } else if(L.type==='text'){
      if(!L.cache) renderTextCache(L);
      ctx.drawImage(L.cache, -L.w/2, -L.h/2, L.w, L.h);
    }
    ctx.restore();
  }
  updateSelectionUI();
  drawGuides();
}

/* ============ Cache texte pour fluidit√© ============ */
function renderTextCache(L){
  const cache = document.createElement('canvas');
  cache.width = Math.max(10, Math.round(L.w));
  const ctx2 = cache.getContext('2d');
  const weight = L.bold ? '800' : '600';
  ctx2.font = `${weight} ${L.size}px ${fontCSS(L.font)}, Inter, system-ui`;
  ctx2.textBaseline='top'; ctx2.textAlign='left'; ctx2.fillStyle=L.color||'#E6ECF7';
  const words = (L.text||'').split(/\s+/);
  const lines=[]; let line='';
  for(const w of words){
    const t=line? line+' '+w : w;
    if(ctx2.measureText(t).width <= cache.width) line=t;
    else{ lines.push(line||w); line = (ctx2.measureText(w).width<=cache.width)? w : w; }
  }
  if(line) lines.push(line);
  const lh = Math.round(L.size*1.25);
  cache.height = Math.max(lh, lines.length*lh);
  const ctx3 = cache.getContext('2d');
  ctx3.font = `${weight} ${L.size}px ${fontCSS(L.font)}, Inter, system-ui`;
  ctx3.textBaseline='top'; ctx3.textAlign='left'; ctx3.fillStyle=L.color||'#E6ECF7';
  let y=0; for(const ln of lines){ ctx3.fillText(ln, 0, y); y+=lh; }
  L.cache = cache;
  L.h = cache.height;
}

/* Forcer le chargement de police */
async function ensureFont(name, size=16){
  try{ await document.fonts.load(`${size}px ${fontCSS(name)}`); }catch(e){}
}

/* ============ S√©lection + poign√©es (cadre tournant) ============ */
function updateSelectionUI(){
  if(!selected){ outline.style.display='none'; handles.classList.add('hidden'); rothandle.style.display='none'; rotline.style.display='none'; return; }
  const L = layers.find(l=> l.id===selected); if(!L){ outline.style.display='none'; handles.classList.add('hidden'); return; }

  const cx=L.x+L.w/2, cy=L.y+L.h/2, a=L.rot||0;
  const ch = worldToHost(cx, cy);
  const rc = rectCanvas(); const sx = rc.width / canvas.width, sy = rc.height / canvas.height;
  const W = L.w*sx, H = L.h*sy;

  outline.style.display='block';
  outline.style.width  = Math.round(W) + 'px';
  outline.style.height = Math.round(H) + 'px';
  outline.style.left = Math.round(ch.x - W/2) + 'px';
  outline.style.top  = Math.round(ch.y - H/2) + 'px';
  outline.style.transform = `rotate(${a}rad)`;

  const corners = {
    tl: rot2D(-W/2,-H/2, a), tr: rot2D( W/2,-H/2, a),
    bl: rot2D(-W/2, H/2, a), br: rot2D( W/2, H/2, a)
  };
  const pos = k => ({ x: ch.x + corners[k].x, y: ch.y + corners[k].y });
  for(const h of hNodes){
    const k=h.dataset.k, p=pos(k);
    h.style.left = (Math.round(p.x) - 8) + 'px';
    h.style.top  = (Math.round(p.y) - 8) + 'px';
  }
  const topCenter = rot2D(0, -H/2 - 28, a);
  const baseTop = { x: ch.x + topCenter.x, y: ch.y + topCenter.y };
  rothandle.style.display='block'; rotline.style.display='block';
  rothandle.style.left = (Math.round(baseTop.x) - 7) + 'px';
  rothandle.style.top  = (Math.round(baseTop.y) - 7) + 'px';
  rotline.style.left   = Math.round(baseTop.x) + 'px';
  rotline.style.top    = Math.round(baseTop.y + 7) + 'px';
  rotline.style.height = '28px';
  rotline.style.transform = `translate(-1px, -28px) rotate(${a}rad)`;
  handles.classList.remove('hidden');
}

/* ============ Hit tests ============ */
function pointInLayerWorld(p, L){
  const cx=L.x+L.w/2, cy=L.y+L.h/2, a=-(L.rot||0);
  const dx=p.x-cx, dy=p.y-cy;
  const q = rot2D(dx,dy,a);
  return (q.x>=-L.w/2 && q.x<=L.w/2 && q.y>=-L.h/2 && q.y<=L.h/2);
}
function hitLayerClient(cx,cy){
  const p = clientToWorld(cx,cy);
  for(let i=layers.length-1;i>=0;i--){
    const L = layers[i];
    if(pointInLayerWorld(p,L)) return L;
  }
  return null;
}
function handleUnderPointer(cx,cy){
  if(rothandle.style.display!=='none'){
    const b=rothandle.getBoundingClientRect();
    if(cx>=b.left && cx<=b.right && cy>=b.top && cy<=b.bottom) return 'rotate';
  }
  for(const h of hNodes){
    const b=h.getBoundingClientRect();
    if(cx>=b.left && cx<=b.right && cy>=b.top && cy<=b.bottom) return h.dataset.k;
  }
  return null;
}

/* ============ Interactions pointeur ============ */
host.addEventListener('pointerdown', (e)=>{
  host.setPointerCapture(e.pointerId);
  const hit = handleUnderPointer(e.clientX,e.clientY);
  const L = layers.find(l=> l.id===selected);

  if(hit==='rotate' && L){
    const c = clientToWorld(e.clientX,e.clientY);
    const ctr = {x:L.x+L.w/2, y:L.y+L.h/2};
    const startAngle = Math.atan2(c.y-ctr.y, c.x-ctr.x);
    dragging = { mode:'rotate', startAngle, base:(L.rot||0), ctr };
    return;
  }
  if(hit && hit!=='rotate' && L){
    const ctr = {x:L.x+L.w/2, y:L.y+L.h/2};
    const p0 = clientToWorld(e.clientX,e.clientY);
    const r0 = Math.hypot(p0.x-ctr.x, p0.y-ctr.y);
    dragging = { mode:'scale', ctr, r0, start:{ w:L.w, h:L.h, size:L.size } };
    return;
  }
  const HL = hitLayerClient(e.clientX,e.clientY);
  if(HL){
    selected = HL.id;
    const rc = rectCanvas();
    const sx = canvas.width / rc.width, sy = canvas.height / rc.height;
    dragging = { mode:'move', startClient:{x:e.clientX,y:e.clientY}, start:{ x:HL.x, y:HL.y }, sx, sy };
  } else {
    selected = null;
  }
  draw(); refreshLayersUI(); syncRightPanel();
});

host.addEventListener('pointermove', (e)=>{
  if(!dragging) return;
  const L = layers.find(l=> l.id===selected); if(!L) return;

  if(dragging.mode==='move'){
    const dx = (e.clientX - dragging.startClient.x) * (canvas.width / rectCanvas().width);
    const dy = (e.clientY - dragging.startClient.y) * (canvas.height / rectCanvas().height);
    L.x = clamp(dragging.start.x + dx, -L.w, canvas.width);
    L.y = clamp(dragging.start.y + dy, -L.h, canvas.height);
  }
  else if(dragging.mode==='scale'){
    const p = clientToWorld(e.clientX,e.clientY);
    const r = Math.max(5, Math.hypot(p.x-dragging.ctr.x, p.y-dragging.ctr.y));
    const f = clamp(r/dragging.r0, 0.1, 10);
    L.w = Math.max(10, Math.round(dragging.start.w * f));
    L.h = Math.max(10, Math.round(dragging.start.h * f));
    if(L.type==='text'){ /* cache reg√©n√©r√© au pointerup */ }
    L.x = Math.round(dragging.ctr.x - L.w/2);
    L.y = Math.round(dragging.ctr.y - L.h/2);
  }
  else if(dragging.mode==='rotate'){
    const p = clientToWorld(e.clientX,e.clientY);
    const a = Math.atan2(p.y-dragging.ctr.y, p.x-dragging.ctr.x);
    L.rot = dragging.base + (a - dragging.startAngle);
  }
  draw();
});

host.addEventListener('pointerup', ()=>{
  if(dragging && dragging.mode==='scale'){
    const L = layers.find(l=> l.id===selected); if(L && L.type==='text'){
      const f = L.w / dragging.start.w;
      L.size = clamp(Math.round((dragging.start.size||72) * f), 8, 400);
      ensureFont(L.font, L.size).then(()=>{ renderTextCache(L); draw(); });
    }
  }
  dragging=null;
});

/* ============ Calques UI ============ */
const layersEl = document.getElementById('layers');
const countEl  = document.getElementById('count');
function typeIcon(t){ return t==='image' ? ico.typeImg() : (t==='rect' ? ico.typeRect() : ico.typeText()); }

function refreshLayersUI(){
  layersEl.innerHTML='';
  for(let i=layers.length-1;i>=0;i--){
    const L = layers[i];
    const row = document.createElement('div');
    row.className = 'item' + (selected===L.id?' active':'');
    const label = (L.type==='image'?'Image':(L.type==='rect'?'Bloc':'Texte'));
    const visIcon = L.visible ? ico.eye() : ico.eyeOff();
    const opVal = Math.round((L.opacity ?? 1) * 100);

    row.innerHTML = `
      <div class="typeico">${typeIcon(L.type)}</div>
      <div class="small">
        ${label}
        <div class="op-wrap"><input class="op" type="range" min="0" max="100" value="${opVal}" title="Opacit√©"></div>
      </div>
      <div style="display:flex;gap:6px">
        <button class="mini vis" title="Afficher/Masquer">${visIcon}</button>
        <button class="mini up" title="Monter">${ico.up()}</button>
        <button class="mini down" title="Descendre">${ico.down()}</button>
        <button class="mini del" title="Supprimer">${ico.trash()}</button>
      </div>`;

    row.onclick = (ev)=>{
      if(ev.target.closest('.vis')){ L.visible=!L.visible; draw(); refreshLayersUI(); return; }
      if(ev.target.closest('.up')) { const j=layers.indexOf(L); if(j<layers.length-1){ layers.splice(j,1); layers.splice(j+1,0,L); draw(); refreshLayersUI(); } return; }
      if(ev.target.closest('.down')) { const j=layers.indexOf(L); if(j>0){ layers.splice(j,1); layers.splice(j-1,0,L); draw(); refreshLayersUI(); } return; }
      if(ev.target.closest('.del')) { const j=layers.indexOf(L); layers.splice(j,1); if(selected===L.id) selected=null; draw(); refreshLayersUI(); syncRightPanel(); return; }
      selected=L.id; draw(); refreshLayersUI(); syncRightPanel();
    };

    const slider = row.querySelector('.op');
    slider.addEventListener('input', (e)=>{
      L.opacity = clamp(parseInt(e.target.value,10)/100, 0, 1);
      draw();
    });

    layersEl.appendChild(row);
  }
  countEl.textContent = layers.length;
}

/* ============ Import / Ajouts / Export ============ */
document.getElementById('btnAddImg').onclick = ()=> document.getElementById('file').click();
document.getElementById('file').addEventListener('change', async (e)=>{
  for(const f of e.target.files){
    const img = await fileToImage(f);
    const s = Math.min((canvas.width*0.8)/img.naturalWidth, (canvas.height*0.8)/img.naturalHeight, 1);
    const w = Math.round(img.naturalWidth*s), h = Math.round(img.naturalHeight*s);
    const L = { id:uid(), type:'image', img, x:Math.round((canvas.width-w)/2), y:Math.round((canvas.height-h)/2), w, h, rot:0, opacity:1, visible:true };
    layers.push(L); selected=L.id;
  }
  e.target.value=''; draw(); refreshLayersUI(); syncRightPanel();
});

document.getElementById('btnAddText').onclick = async ()=>{
  const w = Math.round(canvas.width*0.6);
  const L = { id:uid(), type:'text', text:'Votre texte', font:'Inter', size:72, color:'#E6ECF7', bold:true, x:Math.round((canvas.width-w)/2), y:Math.round((canvas.height*0.35)), w, h:100, rot:0, visible:true, opacity:1 };
  await ensureFont(L.font, L.size); renderTextCache(L);
  layers.push(L); selected=L.id; draw(); refreshLayersUI(); syncRightPanel();
  setTimeout(()=>{ const el=document.getElementById('tContent'); el.focus(); el.select(); }, 40);
};

document.getElementById('btnAddRect').onclick = ()=>{
  const w = Math.round(canvas.width*0.4), h=Math.round(canvas.height*0.25);
  const L = { id:uid(), type:'rect', fill:'#2FE3FF', x:Math.round((canvas.width-w)/2), y:Math.round((canvas.height-h)/2), w, h, rot:0, visible:true, opacity:1 };
  layers.push(L); selected=L.id; draw(); refreshLayersUI(); syncRightPanel();
};

document.getElementById('bgTransparent').addEventListener('change', e=>{ transparent = e.target.checked; });

document.getElementById('btnExport').onclick  = ()=> exportPNG();

/* Dimensions cibles */
function targetSizeFromFmt(val){
  if(val==='916') return [1080,1920];
  if(val==='11')  return [1080,1080];
  if(val==='yt')  return [1280,720];
  return [1920,1080]; // 16:9
}

/* === NOUVEAU COMPORTEMENT FORMAT === */
document.getElementById('fmt').addEventListener('change', (e)=>{
  exportFmt = e.target.value;
  exportAspect = (exportFmt==='916') ? 9/16 :
                 (exportFmt==='11')  ? 1     :
                 (exportFmt==='yt')  ? 16/9  :
                                       16/9;
  drawGuides();
});

/* Dessin du masque de cadrage (assombrir l'ext√©rieur) */
function drawGuides(){
  const W = host.clientWidth, H = host.clientHeight;
  guide.width = W; guide.height = H;
  const g = guide.getContext('2d');
  g.clearRect(0,0,W,H);

  let w = W, h = w / exportAspect;
  if(h > H){ h = H; w = h * exportAspect; }
  const x = Math.round((W - w)/2), y = Math.round((H - h)/2);

  g.save();
  g.fillStyle = 'rgba(0,0,0,0.45)';
  g.fillRect(0,0,W,H);
  g.clearRect(x, y, w, h);
  g.restore();

  g.strokeStyle = 'rgba(47,227,255,0.7)';
  g.lineWidth = 2;
  g.strokeRect(x+0.5, y+0.5, w-1, h-1);
}

/* Export : redessin + crop au ratio s√©lectionn√© */
function exportPNG(){
  const [EW, EH] = targetSizeFromFmt(exportFmt);

  const a = exportAspect;
  let cw = canvas.width, ch = Math.round(cw / a);
  if(ch > canvas.height){ ch = canvas.height; cw = Math.round(ch * a); }
  const cx = Math.round((canvas.width  - cw)/2);
  const cy = Math.round((canvas.height - ch)/2);

  const off = document.createElement('canvas');
  off.width = EW; off.height = EH;
  const c2 = off.getContext('2d', { alpha: true });
  c2.clearRect(0,0,EW,EH);

  c2.save();
  c2.scale(EW / cw, EH / ch);
  c2.translate(-cx, -cy);

  for (const L of layers){
    if (!L.visible) continue;
    c2.save();
    const mx = L.x + L.w/2, my = L.y + L.h/2;
    c2.translate(mx, my); c2.rotate(L.rot || 0);
    c2.globalAlpha = (L.opacity ?? 1);
    if (L.type === 'image'){
      c2.drawImage(L.img, -L.w/2, -L.h/2, L.w, L.h);
    } else if (L.type === 'rect'){
      c2.fillStyle = L.fill || '#888';
      c2.fillRect(-L.w/2, -L.h/2, L.w, L.h);
    } else {
      if (!L.cache) renderTextCache(L);
      c2.drawImage(L.cache, -L.w/2, -L.h/2, L.w, L.h);
    }
    c2.restore();
  }

  if (!transparent){
    c2.globalCompositeOperation = 'destination-over';
    const g = c2.createLinearGradient(0,0,EW,EH);
    g.addColorStop(0,'#0d1120'); g.addColorStop(1,'#0a0f18');
    c2.fillStyle = g; c2.fillRect(0,0,EW,EH);

    const halo = c2.createRadialGradient(EW*0.2,EH*0.2,0, EW*0.2,EH*0.2, Math.min(EW,EH)*0.65);
    halo.addColorStop(0,'rgba(47,227,255,.16)');
    halo.addColorStop(1,'rgba(47,227,255,0)');
    c2.fillStyle = halo; c2.fillRect(0,0,EW,EH);
  }

  c2.restore();

  const aTag = document.createElement('a');
  aTag.href = off.toDataURL('image/png');
  aTag.download = 'studio-express.png';
  aTag.click();

  off.width = off.height = 0;
}

/* ============ Panneau de droite (texte + bloc) ============ */
const tContent = document.getElementById('tContent');
const tFont    = document.getElementById('tFont');
const tSize    = document.getElementById('tSize');
const tColor   = document.getElementById('tColor');
const tBold    = document.getElementById('tBold');
const colorPal = document.getElementById('colorPal');

function buildPalette(){
  const cols=['#FFFFFF','#E6ECF7','#2FE3FF','#1B4CFF','#00FFAA','#FFD400','#FF5C5C','#C084FC','#111827','#0d1120','#0a0f18'];
  colorPal.innerHTML=''; cols.forEach(c=>{
    const d=document.createElement('div'); d.className='sw'; d.style.background=c;
    d.onclick=()=> applyColor(c);
    colorPal.appendChild(d);
  });
}
buildPalette();

function applyColor(hex){
  const L = layers.find(l=> l.id===selected);
  if(!L) return;
  if(L.type==='text'){ L.color=hex; renderTextCache(L); tColor.value=hex; }
  if(L.type==='rect'){ L.fill=hex; tColor.value=hex; }
  draw();
}

function syncRightPanel(){
  const L = layers.find(l=> l.id===selected);
  const isText = !!(L && L.type==='text');
  const isRect = !!(L && L.type==='rect');

  [tContent,tFont,tSize,tBold].forEach(el=> el.disabled = !isText);
  tColor.disabled = !(isText||isRect);

  if(!L){ tContent.value=''; return; }
  if(isText){
    tContent.value = L.text||'';
    tFont.value    = L.font||'Inter';
    tSize.value    = L.size||72;
    tColor.value   = L.color||'#E6ECF7';
    tBold.checked  = !!L.bold;
  } else if(isRect){
    tContent.value = '';
    tColor.value   = L.fill||'#2FE3FF';
  }
}

tContent.addEventListener('input', ()=>{
  const L = layers.find(l=> l.id===selected && l.type==='text'); if(!L) return;
  L.text = tContent.value; renderTextCache(L); draw();
});
tFont.addEventListener('change', async ()=>{
  const L = layers.find(l=> l.id===selected && l.type==='text'); if(!L) return;
  L.font = tFont.value; await ensureFont(L.font, L.size); renderTextCache(L); draw();
});
tSize.addEventListener('input', ()=>{
  const L = layers.find(l=> l.id===selected && l.type==='text'); if(!L) return;
  L.size = clamp(parseInt(tSize.value||'72',10), 8, 400);
  ensureFont(L.font, L.size).then(()=>{ renderTextCache(L); draw(); });
});
tColor.addEventListener('input', ()=>{
  const L = layers.find(l=> l.id===selected); if(!L) return;
  if(L.type==='text'){ L.color=tColor.value; renderTextCache(L); }
  if(L.type==='rect'){ L.fill=tColor.value; }
  draw();
});
tBold.addEventListener('change', ()=>{
  const L = layers.find(l=> l.id===selected && l.type==='text'); if(!L) return;
  L.bold = tBold.checked; renderTextCache(L); draw();
});

/* ============ Zoom aper√ßu (Alt + molette) ============ */
function applyViewScale(){ canvas.style.transform = `scale(${viewScale})`; updateSelectionUI(); }
host.addEventListener('wheel', (e)=>{
  if(!e.altKey) return;
  e.preventDefault();
  const dir = Math.sign(e.deltaY);
  viewScale = clamp(viewScale * (dir>0 ? 0.9 : 1.1111), 0.5, 3);
  applyViewScale();
}, {passive:false});

/* ============ Utils ============ */
function fileToImage(file){
  return new Promise((res,rej)=>{
    const img = new Image();
    img.onload = ()=> res(img);
    img.onerror = rej;
    img.src = URL.createObjectURL(file);
  });
}
function loadExternalImage(url){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    img.crossOrigin='anonymous';
    img.onload = ()=> resolve(img);
    img.onerror = reject;
    const sep = url.includes('?') ? '&' : '?';
    img.src = url + sep + 'ref=studio-express';
  });
}

/* ============ Init ============ */
document.fonts.ready.then(()=>{ draw(); drawGuides(); });
draw(); refreshLayersUI(); syncRightPanel();

/* D√©s√©lection hors sc√®ne */
document.addEventListener('pointerdown', (e)=>{
  if(!host.contains(e.target) && !e.target.closest('.side')){ selected=null; draw(); refreshLayersUI(); syncRightPanel(); }
});

/* Recalage guides/handles si redimension d‚Äôaffichage */
window.addEventListener('resize', ()=>{ drawGuides(); updateSelectionUI(); });

/* ===== BANQUE D'IMAGES (Pexels, cl√© int√©gr√©e) ===== */
(function(){
  const PEXELS_KEY = 'GckQdbK9Nh5aBvlnM6hnyGIs1aUZtPImGJTEKzpPb1VoXnRhk1tjtxvY';
  const qEl    = document.getElementById('stockQuery');
  const btn    = document.getElementById('stockSearch');
  const grid   = document.getElementById('stockGrid');
  const more   = document.getElementById('stockMore');
  const state = { mode:'curated', q:'', page:1, hasMore:false };

  btn.addEventListener('click', ()=>{ state.mode='search'; state.page=1; state.q=(qEl.value||'').trim()||'wallpaper'; fetchAndRender(true); });
  qEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ state.mode='search'; state.page=1; state.q=(qEl.value||'').trim()||'wallpaper'; fetchAndRender(true); }});
  more.addEventListener('click', ()=>{ state.page++; fetchAndRender(false); });
  document.addEventListener('DOMContentLoaded', ()=>{ fetchAndRender(true); });

  async function fetchAndRender(reset){
    try{
      let url = state.mode==='curated'
        ? `https://api.pexels.com/v1/curated?per_page=24&page=${state.page}`
        : `https://api.pexels.com/v1/search?query=${encodeURIComponent(state.q||'wallpaper')}&per_page=24&page=${state.page}`;
      const res = await fetch(url, { headers:{ Authorization: PEXELS_KEY }});
      if(!res.ok) throw new Error('Pexels error');
      const data = await res.json();
      const photos = data.photos || [];
      const items = photos.map(p=>({ id:`px_${p.id}`, thumb:p.src.medium, full:p.src.large2x || p.src.large || p.src.original, alt:p.alt||'Pexels', w:p.width, h:p.height }));
      if(reset) grid.innerHTML='';
      items.forEach(it=>{
        const card=document.createElement('div');
        card.className='thumb'; card.title='Ajouter √† la sc√®ne';
        card.innerHTML=`<img loading="lazy" src="${it.thumb}" alt=""><div class="cap">${it.alt}</div>`;
        card.addEventListener('click', ()=> addFromURL(it.full));
        grid.appendChild(card);
      });
      const per = data.per_page || 24;
      const total = data.total_results ?? 100000;
      state.hasMore = (state.page * per) < total;
      more.style.display = state.hasMore ? '' : 'none';
    }catch(err){ console.error(err); alert('Impossible de charger les images depuis Pexels.'); }
  }

  async function addFromURL(url){
    try{
      const img = await loadExternalImage(url);
      const s = Math.min((canvas.width*0.8)/img.naturalWidth, (canvas.height*0.8)/img.naturalHeight, 1);
      const w = Math.round(img.naturalWidth*s), h = Math.round(img.naturalHeight*s);
      const L = { id:uid(), type:'image', img, x:Math.round((canvas.width-w)/2), y:Math.round((canvas.height-h)/2), w, h, rot:0, opacity:1, visible:true };
      layers.push(L); selected=L.id; draw(); refreshLayersUI(); syncRightPanel();
    }catch(e){ console.error(e); alert('√âchec de chargement de l‚Äôimage distante.'); }
  }
})();

/* ===== STICKERS : banque GitHub infinieetgratuit/stickers ===== */
(function(){
  const BTN   = document.getElementById('btnStickers');
  const PANEL = document.getElementById('stickersPanel');
  const GRID  = document.getElementById('stickersGrid');
  const HINT  = document.getElementById('stickersHint');

  const GITHUB_OWNER = 'infinieetgratuit';
  const GITHUB_REPO  = 'stickers';
  const IMG_EXT = /\.(png|jpe?g|webp|gif|svg)$/i;

  let loaded = false; // √©viter de rafra√Æchir plusieurs fois

  BTN.addEventListener('click', async ()=>{
    PANEL.style.display = '';
    if(!loaded){
      await loadGitHubStickers();
      loaded = true;
    }
  });

  async function loadGitHubStickers(){
    GRID.innerHTML='';
    HINT.textContent = 'Chargement des stickers depuis GitHub‚Ä¶';

    try{
      // 1) R√©cup√®re la branche par d√©faut
      const repoRes = await fetch(`https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}`, {
        headers:{ 'Accept':'application/vnd.github+json' }
      });
      if(!repoRes.ok) throw new Error('Repo introuvable');
      const repo = await repoRes.json();
      const branch = repo.default_branch || 'main';

      // 2) Liste TOUT l‚Äôarbre en une requ√™te (recursive)
      const treeRes = await fetch(`https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/git/trees/${encodeURIComponent(branch)}?recursive=1`, {
        headers:{ 'Accept':'application/vnd.github+json' }
      });
      if(!treeRes.ok) throw new Error('Arbre Git introuvable');
      const tree = await treeRes.json();

      const files = (tree.tree || [])
        .filter(n => n.type === 'blob' && IMG_EXT.test(n.path || ''));

      if(!files.length){
        HINT.innerHTML = `Aucune image trouv√©e dans <b>${GITHUB_OWNER}/${GITHUB_REPO}</b>.`;
        return;
      }

      HINT.textContent = 'Clique un sticker pour l‚Äôajouter comme calque.';

      // 3) Construit les URLs brutes (CORS OK, export canvas OK)
      const toRaw = (p)=> `https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${branch}/${encodeURI(p)}`;

      for(const f of files){
        const raw = toRaw(f.path);
        const name = f.path.split('/').pop();
        const card = document.createElement('div');
        card.className = 'thumb';
        card.title = 'Ajouter √† la sc√®ne';
        // on utilise la m√™me URL pour l‚Äôaper√ßu (simple et fiable)
        card.innerHTML = `<img loading="lazy" src="${raw}" alt=""><div class="cap">${name}</div>`;
        card.addEventListener('click', ()=> addStickerFromRaw(raw));
        GRID.appendChild(card);
      }
    }catch(e){
      console.error(e);
      HINT.innerHTML = `Impossible de charger la banque GitHub. <br>V√©rifie le d√©p√¥t public : <a href="https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}" target="_blank" rel="noopener">github.com/${GITHUB_OWNER}/${GITHUB_REPO}</a>`;
    }
  }

  async function addStickerFromRaw(url){
    try{
      const img = await new Promise((resolve,reject)=>{
        const im = new Image();
        im.crossOrigin = 'anonymous'; // important pour l‚Äôexport PNG
        im.onload = ()=> resolve(im);
        im.onerror = reject;
        // pas de param√®tres additifs pour raw.githubusercontent, CORS d√©j√† OK
        im.src = url;
      });
      const s = Math.min((canvas.width*0.8)/img.naturalWidth, (canvas.height*0.8)/img.naturalHeight, 1);
      const w = Math.round(img.naturalWidth*s), h = Math.round(img.naturalHeight*s);
      const L = { id:uid(), type:'image', img, x:Math.round((canvas.width-w)/2), y:Math.round((canvas.height-h)/2), w, h, rot:0, opacity:1, visible:true };
      layers.push(L); selected=L.id; draw(); refreshLayersUI(); syncRightPanel();
    }catch(err){
      console.error(err);
      alert("√âchec de chargement du sticker depuis GitHub.");
    }
  }
})();
</script>
</body>
</html>
