<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pokédex Infini</title>
    
    <!-- Styling & Fonts -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <!-- React & Babel for in-browser transpilation -->
    <script src="https://aistudiocdn.com/react@^19.2.0"></script>
    <script src="https://aistudiocdn.com/react-dom@^19.2.0/client"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        font-family: 'Inter', sans-serif;
      }
      .custom-scrollbar::-webkit-scrollbar {
        width: 8px;
      }
      .custom-scrollbar::-webkit-scrollbar-track {
        background: #101218CC;
      }
      .custom-scrollbar::-webkit-scrollbar-thumb {
        background-color: #FFCB05; /* Pokémon Yellow */
        border-radius: 20px;
        border: 2px solid #101218CC;
      }
      .animated-grid-background {
        background-image: linear-gradient(rgba(255, 203, 5, 0.03) 1px, transparent 1px), linear-gradient(to right, rgba(255, 203, 5, 0.03) 1px, transparent 1px);
        background-size: 60px 60px;
        animation: drift 60s linear infinite;
      }
      @keyframes drift {
        0% { background-position: 0 0; }
        100% { background-position: 1200px 600px; }
      }
       @keyframes card-add-animation {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }
      .animate-card-add {
        animation: card-add-animation 0.3s ease-out forwards;
      }
    </style>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'brand-dark': '#0A0A0B',
              'brand-light': '#F2F3F6',
              'brand-gray': '#A5A9B3',
              'brand-yellow': {
                'DEFAULT': '#FFCB05',
                'light': '#FFDE59',
                'dark': '#D4A800',
              },
              'brand-blue': '#2D5499',
              'brand-red': '#EE1515',
              'brand-panel': 'rgba(16, 18, 24, 0.8)',
            },
            boxShadow: {
              'yellow-glow': '0 0 15px rgba(255, 203, 5, 0.4)',
              'yellow-glow-hover': '0 0 25px rgba(255, 203, 5, 0.6)',
            }
          }
        }
      }
    </script>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React from 'react';
      import ReactDOM from 'react-dom/client';
      const { useState, useEffect, useCallback, useRef } = React;

      // --- PDF Exporter Service ---
      const generateStyledPDF = async (element, userInfo) => {
        const { jsPDF } = jspdf;
        
        try {
          const canvas = await html2canvas(element, { 
              scale: 2, 
              useCORS: true, 
              backgroundColor: null 
          });
          const imgData = canvas.toDataURL('image/png');
          
          const imgWidth = 210;
          const pageHeight = 297;
          const imgHeight = canvas.height * imgWidth / canvas.width;
          let heightLeft = imgHeight;
          
          const doc = new jsPDF('p', 'mm');
          let position = 0;

          doc.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
          heightLeft -= pageHeight;

          while (heightLeft >= 0) {
            position = heightLeft - imgHeight;
            doc.addPage();
            doc.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
            heightLeft -= pageHeight;
          }
          
          doc.save(`Classeur_Pokemon_${userInfo.name.replace(/\s/g, '_')}.pdf`);

        } catch (error) {
          console.error("Erreur lors de la génération du PDF stylisé:", error);
          alert("Une erreur est survenue lors de la génération du PDF. Voir la console pour plus de détails.");
        }
      };

      const generateProfessionalPDF = async (cards, userInfo) => {
        const { jsPDF } = jspdf;
        const doc = new jsPDF();

        doc.setFontSize(22);
        doc.setTextColor('#2D5499'); // Pokémon Blue
        doc.text("Inventaire de Collection de Cartes Pokémon", 14, 22);

        doc.setFontSize(12);
        doc.setTextColor('#0A0A0B');
        doc.text(`Dresseur: ${userInfo.name}`, 14, 32);
        if (userInfo.info) {
          doc.text(`Informations: ${userInfo.info}`, 14, 40);
        }
        doc.text(`Date de génération: ${new Date().toLocaleDateString('fr-FR')}`, 14, 48);
        
        const tableColumn = ["ID", "Nom de la Carte", "Type", "Prix (EUR)", "Prix (USD)"];
        const tableRows = [];

        let totalEUR = 0;
        let totalUSD = 0;

        cards.forEach(card => {
          const cardData = [
            card.id,
            card.name,
            card.type,
            (card.prices.eur || 0).toFixed(2),
            (card.prices.usd || 0).toFixed(2),
          ];
          tableRows.push(cardData);
          totalEUR += card.prices.eur || 0;
          totalUSD += card.prices.usd || 0;
        });

        doc.autoTable({
          head: [tableColumn],
          body: tableRows,
          startY: 60,
          theme: 'grid',
          headStyles: { fillColor: [45, 84, 153] }, // #2D5499
          styles: { font: 'Inter' }
        });

        const finalY = doc.lastAutoTable.finalY;
        doc.setFontSize(14);
        doc.text("Résumé de la Valeur Totale", 14, finalY + 20);
        doc.setFontSize(12);
        doc.text(`Valeur Totale (EUR): ${totalEUR.toFixed(2)} €`, 14, finalY + 28);
        doc.text(`Valeur Totale (USD): ${totalUSD.toFixed(2)} $`, 14, finalY + 36);

        const pageCount = doc.internal.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
          doc.setPage(i);
          doc.setFontSize(10);
          doc.setTextColor(150);
          doc.text(`Page ${i} sur ${pageCount}`, doc.internal.pageSize.width - 25, 285);
        }

        doc.save(`Assurance_Pokemon_${userInfo.name.replace(/\s/g, '_')}.pdf`);
      };

      // --- Components ---
      
      const PokeBallIcon = ({ className }) => (
        <div className={`relative ${className}`}>
          <div className="w-full h-full rounded-full bg-white border-2 border-brand-dark">
            <div className="absolute top-0 left-0 w-full h-1/2 bg-brand-red rounded-t-full"></div>
            <div className="absolute top-1/2 left-0 w-full h-[2px] bg-brand-dark transform -translate-y-1/2"></div>
            <div className="absolute top-1/2 left-1/2 w-1/3 h-1/3 rounded-full bg-white border-2 border-brand-dark transform -translate-x-1/2 -translate-y-1/2"></div>
          </div>
        </div>
      );

      const Header = ({ onExportClick, binderSize }) => {
        return (
          <header className="bg-brand-panel/50 backdrop-blur-lg border-b border-brand-yellow/20 sticky top-0 z-50">
            <div className="container mx-auto px-4 py-3 flex justify-between items-center">
              <div className="flex items-center gap-4">
                <PokeBallIcon className="w-8 h-8"/>
                <h1 className="text-xl font-bold uppercase tracking-[0.2em] text-brand-light hidden sm:block">
                  Pokédex Infini
                </h1>
              </div>
              <button
                onClick={onExportClick}
                className="group relative inline-flex items-center justify-center px-6 py-2 text-sm font-bold tracking-wider text-brand-dark bg-brand-yellow rounded-full overflow-hidden transition-all duration-300 ease-out hover:shadow-yellow-glow-hover focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-brand-dark focus:ring-brand-yellow-light"
              >
                <span className="absolute inset-0 w-0 bg-brand-yellow-light transition-all duration-300 ease-out group-hover:w-full"></span>
                <span className="relative flex items-center gap-2">
                  Exporter
                  {binderSize > 0 && (
                    <span className="bg-brand-dark text-brand-yellow-light text-xs font-semibold rounded-full h-5 w-5 flex items-center justify-center">
                      {binderSize}
                    </span>
                  )}
                </span>
              </button>
            </div>
          </header>
        );
      };

      const CardSearchResult = ({ card, onAdd }) => {
        return (
          <div className="flex items-center justify-between bg-black/30 p-2 rounded-lg border border-transparent hover:border-brand-yellow/50 hover:bg-brand-yellow/10 transition-all duration-200">
            <div className="flex items-center gap-3 overflow-hidden">
              <img src={card.imageUrl} alt={card.name} className="w-10 h-10 rounded-md object-cover flex-shrink-0" />
              <div className="truncate">
                <p className="font-semibold text-brand-light truncate">{card.name}</p>
                <p className="text-sm text-brand-gray truncate">{card.type}</p>
              </div>
            </div>
            <button
              onClick={() => onAdd(card)}
              className="text-brand-yellow hover:text-brand-yellow-light text-2xl font-light px-2 rounded-full transition-colors"
              aria-label={`Ajouter ${card.name}`}
            >
              +
            </button>
          </div>
        );
      };

      const BinderCardComponent = ({ card, onRemove }) => {
        return (
          <div className="group relative aspect-[734/1024] overflow-hidden rounded-2xl shadow-lg transition-all duration-300 transform hover:scale-105 hover:shadow-yellow-glow animate-card-add">
            <img src={card.imageUrl} alt={card.name} className="w-full h-full object-cover" />
            <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300 p-2 flex flex-col justify-end">
              <h4 className="text-white font-bold text-xs leading-tight mb-1">{card.name}</h4>
              <p className="text-brand-yellow-light font-semibold text-sm">{(card.prices.eur || 0).toFixed(2)} €</p>
            </div>
            <button 
              onClick={() => onRemove(card.binderId)}
              className="absolute top-2 right-2 bg-brand-red/70 text-white w-6 h-6 rounded-full flex items-center justify-center text-sm font-bold opacity-0 group-hover:opacity-100 transition-all duration-300 hover:bg-brand-red hover:scale-110"
              aria-label={`Retirer ${card.name}`}
            >
              &times;
            </button>
          </div>
        );
      };

      const BinderView = ({ cards, onRemove }) => {
        const totalValueEUR = cards.reduce((sum, card) => sum + (card.prices.eur || 0), 0).toFixed(2);

        return (
          <div className="bg-brand-panel backdrop-blur-md border border-brand-yellow/30 rounded-2xl p-6 shadow-lg h-full">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-2xl font-bold uppercase tracking-widest text-brand-yellow">Mon Classeur</h2>
              <div className="text-right">
                <p className="text-lg font-semibold text-brand-light">{totalValueEUR} €</p>
                <p className="text-sm text-brand-gray">Valeur Totale (EUR)</p>
              </div>
            </div>
            <div className="h-[calc(100vh-250px)] overflow-y-auto custom-scrollbar pr-2 -mr-2">
              {cards.length > 0 ? (
                <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-3 xl:grid-cols-4 gap-4">
                  {cards.map(card => (
                    <BinderCardComponent key={card.binderId} card={card} onRemove={onRemove} />
                  ))}
                </div>
              ) : (
                <div className="relative flex items-center justify-center h-full">
                  <div className="absolute text-brand-yellow/5 text-[20rem] font-black select-none z-0 flex items-center justify-center">
                     <PokeBallIcon className="w-full h-full opacity-20"/>
                  </div>
                  <div className="text-center text-brand-gray z-10">
                    <p className="text-lg font-semibold">Votre classeur est vide.</p>
                    <p>Recherchez et ajoutez des cartes pour commencer votre collection.</p>
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      };

      const ExportModal = ({ onClose, binderCards }) => {
        const [userName, setUserName] = useState('');
        const [userInfo, setUserInfo] = useState('');
        const [isGenerating, setIsGenerating] = useState(false);
        const binderRef = useRef(null);

        const imagesReady = binderCards.length === 0 || binderCards.every(c => !!c.dataURL);

        const handleStyledExport = async () => {
          if (!userName || !binderRef.current || !imagesReady) return;
          setIsGenerating(true);
          
          try {
            await new Promise(resolve => setTimeout(resolve, 100));
            await generateStyledPDF(binderRef.current, { name: userName, info: userInfo });
          } catch (error) {
            console.error("Erreur lors de la génération du PDF stylisé", error);
            alert("Une erreur est survenue lors de la préparation de l'export.");
          } finally {
            setIsGenerating(false);
            onClose();
          }
        };
        
        const handleProfessionalExport = async () => {
          if (!userName) return;
          setIsGenerating(true);
          await generateProfessionalPDF(binderCards, { name: userName, info: userInfo });
          setIsGenerating(false);
          onClose();
        };

        return (
          <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div className="bg-brand-panel border border-brand-yellow/30 rounded-2xl w-full max-w-2xl shadow-yellow-glow p-8 relative max-h-[90vh] flex flex-col">
              <button onClick={onClose} className="absolute top-4 right-4 text-brand-gray hover:text-brand-light transition-colors text-3xl leading-none">&times;</button>
              <h2 className="text-2xl font-bold uppercase tracking-widest text-brand-yellow mb-6">Exporter l'Album</h2>
              
              <div className="flex-grow overflow-y-auto custom-scrollbar pr-4 -mr-4">
                <div className="space-y-4">
                  <div>
                    <label htmlFor="userName" className="block text-sm font-medium text-brand-gray mb-1">Votre Nom de Dresseur</label>
                    <input type="text" id="userName" value={userName} onChange={e => setUserName(e.target.value)} className="w-full bg-black/50 border border-brand-yellow/30 rounded-lg py-2 px-4 text-brand-light placeholder-brand-gray focus:outline-none focus:ring-2 focus:ring-brand-yellow-light transition-all" placeholder="Ex: Sacha Ketchum" />
                  </div>
                  <div>
                    <label htmlFor="userInfo" className="block text-sm font-medium text-brand-gray mb-1">Informations Additionnelles (pour l'export)</label>
                    <textarea id="userInfo" value={userInfo} onChange={e => setUserInfo(e.target.value)} rows={3} className="w-full bg-black/50 border border-brand-yellow/30 rounded-lg py-2 px-4 text-brand-light placeholder-brand-gray focus:outline-none focus:ring-2 focus:ring-brand-yellow-light transition-all" placeholder="Ex: Adresse, informations pour assurance, etc."></textarea>
                  </div>
                </div>

                <div className="absolute -left-[9999px] -top-[9999px]" aria-hidden="true">
                  <div ref={binderRef} className="p-10 bg-gray-800" style={{width: '1240px'}}>
                    <h2 className="text-4xl font-bold text-brand-yellow mb-4">Classeur de {userName || 'Dresseur'}</h2>
                    <div className="grid grid-cols-5 gap-4">
                       {binderCards.map(card => (
                         card.dataURL ? (
                           <div key={card.binderId} className="aspect-[734/1024] rounded-lg overflow-hidden relative">
                              <img src={card.dataURL} alt={card.name} className="w-full h-full object-cover"/>
                              <div className="absolute bottom-0 left-0 right-0 bg-black/60 p-1">
                                <p className="text-white text-xs font-bold truncate">{card.name}</p>
                                <p className="text-brand-yellow-light text-xs font-semibold">{(card.prices.eur || 0).toFixed(2)} €</p>
                              </div>
                           </div>
                         ) : null
                       ))}
                    </div>
                  </div>
                </div>
              </div>

              <div className="mt-6 pt-6 border-t border-brand-yellow/20 flex flex-col sm:flex-row gap-4">
                <div className="flex-1 flex flex-col items-center">
                  <button 
                    onClick={handleStyledExport} 
                    disabled={isGenerating || !userName || !imagesReady} 
                    className="w-full group relative inline-flex items-center justify-center px-6 py-3 text-sm font-bold tracking-wider text-brand-dark bg-brand-yellow rounded-full overflow-hidden transition-all duration-300 ease-out hover:shadow-yellow-glow-hover disabled:bg-brand-gray disabled:cursor-not-allowed"
                  >
                    <span className="absolute inset-0 w-0 bg-brand-yellow-light transition-all duration-300 ease-out group-hover:w-full"></span>
                    <span className="relative">{isGenerating ? 'Génération...' : 'Export Stylisé (Classeur)'}</span>
                  </button>
                  {!imagesReady && binderCards.length > 0 && (
                    <p className="text-xs text-brand-yellow mt-2 animate-pulse">Préparation des images pour l'export...</p>
                  )}
                </div>
                <button onClick={handleProfessionalExport} disabled={isGenerating || !userName} className="flex-1 group relative inline-flex items-center justify-center px-6 py-3 text-sm font-bold tracking-wider text-brand-light bg-transparent border-2 border-brand-yellow rounded-full overflow-hidden transition-all duration-300 ease-out hover:bg-brand-yellow hover:text-brand-dark disabled:border-brand-gray disabled:text-brand-gray disabled:cursor-not-allowed">
                  <span className="relative">{isGenerating ? 'Génération...' : 'Export Professionnel (Assurance)'}</span>
                </button>
              </div>
            </div>
          </div>
        );
      };

      // --- Main App Component ---

      const CORS_PROXY = 'https://api.allorigins.win/raw?url=';

      const fetchImageDataURL = async (url) => {
        try {
          const response = await fetch(`${CORS_PROXY}${encodeURIComponent(url)}`);
          if (!response.ok) {
              throw new Error(`Failed to fetch image: ${response.statusText}`);
          }
          const blob = await response.blob();
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        } catch (error) {
          console.warn(`Could not fetch image via proxy, using original URL. This may cause issues with PDF export. Error: ${error}`);
          return url;
        }
      };

      const LoadingSpinner = () => (
          <div className="flex justify-center items-center p-4">
              <svg className="animate-spin h-8 w-8 text-brand-yellow" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
          </div>
      );

      function App() {
        const [searchTerm, setSearchTerm] = useState('');
        const [searchResults, setSearchResults] = useState([]);
        const [isSearching, setIsSearching] = useState(false);
        const [searchError, setSearchError] = useState(null);
        const [binderCards, setBinderCards] = useState([]);
        const [isExporting, setIsExporting] = useState(false);
        const [nextBinderId, setNextBinderId] = useState(1);
        const debounceTimeout = useRef(null);

        const fetchCards = useCallback(async (query) => {
          setIsSearching(true);
          setSearchError(null);
          setSearchResults([]);
          try {
            const response = await fetch(`https://api.pokemontcg.io/v2/cards?q=name:"${encodeURIComponent(query)}*"`);
            
            if (!response.ok) {
              throw new Error(`Erreur de l'API: ${response.statusText}`);
            }
            
            const result = await response.json();

            if (!result.data) {
              setSearchResults([]);
              return;
            }

            const transformedCards = result.data.map((apiCard) => ({
              id: apiCard.id,
              name: apiCard.name,
              type: apiCard.subtypes ? apiCard.subtypes.join(', ') : apiCard.supertype,
              imageUrl: apiCard.images.large,
              prices: {
                eur: apiCard.cardmarket?.prices?.averageSellPrice || 0,
                usd: (apiCard.tcgplayer?.prices?.holofoil?.market || apiCard.tcgplayer?.prices?.unlimitedHolofoil?.market || apiCard.tcgplayer?.prices?.normal?.market) || 0,
              },
            })).filter((card) => card.imageUrl);

            setSearchResults(transformedCards.slice(0, 50));

          } catch (error) {
            console.error("Failed to fetch cards:", error);
            setSearchError("Une erreur est survenue lors de la recherche.");
          } finally {
            setIsSearching(false);
          }
        }, []);

        useEffect(() => {
          if (debounceTimeout.current) {
            clearTimeout(debounceTimeout.current);
          }
          if (searchTerm.trim() === '') {
            setSearchResults([]);
            setIsSearching(false);
            setSearchError(null);
            return;
          }

          setIsSearching(true);
          debounceTimeout.current = window.setTimeout(() => {
            fetchCards(searchTerm);
          }, 500);
          
          return () => {
              if(debounceTimeout.current) clearTimeout(debounceTimeout.current);
          }
        }, [searchTerm, fetchCards]);

        const addCardToBinder = useCallback((cardToAdd) => {
          const newBinderCard = {
            ...cardToAdd,
            binderId: nextBinderId,
          };
          setBinderCards(prev => [...prev, newBinderCard]);
          setNextBinderId(prevId => prevId + 1);

          fetchImageDataURL(newBinderCard.imageUrl).then(dataURL => {
            setBinderCards(currentCards => 
              currentCards.map(card => 
                card.binderId === newBinderCard.binderId ? { ...card, dataURL } : card
              )
            );
          });
        }, [nextBinderId]);


        const removeCardFromBinder = (binderIdToRemove) => {
          setBinderCards(prev => prev.filter(card => card.binderId !== binderIdToRemove));
        };

        return (
          <div className="bg-brand-dark min-h-screen text-brand-light font-sans animated-grid-background relative overflow-hidden">
            <div className="absolute inset-0 bg-gradient-to-br from-brand-yellow/5 via-transparent to-brand-dark -z-10"></div>
             <div className="absolute top-1/2 left-1/2 w-[150%] h-[150%] -translate-x-1/2 -translate-y-1/2 bg-radial-gradient(circle_at_center,_rgba(255,203,5,0.05)_0,_rgba(255,203,5,0)_50%) animate-pulse-slow"></div>
            
            <Header onExportClick={() => setIsExporting(true)} binderSize={binderCards.length} />

            <main className="container mx-auto p-4 lg:p-8 grid grid-cols-1 lg:grid-cols-3 gap-8 items-start">
              <div className="lg:col-span-1 space-y-6 sticky top-24">
                <div className="bg-brand-panel backdrop-blur-md border border-brand-yellow/30 rounded-2xl p-6 shadow-lg">
                  <h2 className="text-2xl font-bold uppercase tracking-widest text-brand-yellow mb-4">Rechercher</h2>
                  <div className="relative">
                    <input
                      type="text"
                      value={searchTerm}
                      onChange={e => setSearchTerm(e.target.value)}
                      placeholder="Ex: Dracaufeu"
                      className="w-full bg-black/50 border border-brand-yellow/30 rounded-full py-3 px-6 text-brand-light placeholder-brand-gray focus:outline-none focus:ring-2 focus:ring-brand-yellow-light transition-all"
                    />
                  </div>
                </div>
                <div className="space-y-2 max-h-[calc(100vh-350px)] overflow-y-auto custom-scrollbar pr-2">
                  {isSearching && <LoadingSpinner />}
                  {searchError && (
                    <div className="text-center text-red-400 p-4">{searchError}</div>
                  )}
                  {!isSearching && !searchError && searchResults.map(card => (
                    <CardSearchResult key={card.id} card={card} onAdd={addCardToBinder} />
                  ))}
                  {!isSearching && searchTerm && searchResults.length === 0 && !searchError && (
                    <div className="text-center text-brand-gray p-4">
                      Aucune carte trouvée pour "{searchTerm}".
                    </div>
                  )}
                </div>
              </div>

              <div className="lg:col-span-2">
                <BinderView cards={binderCards} onRemove={removeCardFromBinder} />
              </div>
            </main>

            {isExporting && (
              <ExportModal binderCards={binderCards} onClose={() => setIsExporting(false)} />
            )}

            <footer className="text-center py-4 text-brand-gray text-sm">
              <p>Attrapez-les tous ! Non affilié à Nintendo ou The Pokémon Company.</p>
            </footer>
          </div>
        );
      }

      // --- App Initialization ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>