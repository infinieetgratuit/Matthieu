<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Trainer Modèle IA · Infinie & gratuit</title>
<style>
:root{
  --bg:#0A0A0B;
  --text:#F2F3F6;
  --muted:#A5A9B3;
  --gold-1:#D8B45A;
  --gold-2:#F2C76C;
  --gold-3:#BF8E2C;
  --panel:rgba(16,18,24,0.8);
  --border:rgba(212,172,82,0.22);
  --radius:14px;
  --grid:#F2C76C22;
  --danger:#FF6B6B;
  --ok:#7CFC9A;
  --warn:#F2C76C;
  --font-stack:system-ui,-apple-system,BlinkMacSystemFont,"Inter",Roboto,"Helvetica Neue",Arial,sans-serif;
}

/* FOND global : noir + halo or + grille or transparente */
body{
  background-color:var(--bg);
  color:var(--text);
  font-family:var(--font-stack);
  min-height:100vh;
  margin:0;
  padding:24px;
  display:flex;
  flex-direction:column;
  gap:24px;
  position:relative;
  overflow-x:hidden;
}
body::before{
  content:"";
  position:absolute;
  left:50%;
  top:25%;
  width:600px;
  height:600px;
  background:radial-gradient(circle at 50% 50%, rgba(242,199,108,0.18) 0%, rgba(0,0,0,0) 70%);
  filter:blur(60px);
  transform:translate(-50%,-50%);
  pointer-events:none;
  z-index:0;
}
body::after{
  content:"";
  position:absolute;
  inset:0;
  background-image:
    linear-gradient(to right, var(--grid) 1px, transparent 1px),
    linear-gradient(to bottom, var(--grid) 1px, transparent 1px);
  background-size:40px 40px;
  mask-image:radial-gradient(circle at 50% 30%, rgba(0,0,0,1) 0%, rgba(0,0,0,0) 70%);
  pointer-events:none;
  z-index:0;
}

/* HEADER GLOBAL */
.appHeader{
  position:relative;
  z-index:2;
  display:flex;
  flex-wrap:wrap;
  align-items:flex-start;
  justify-content:space-between;
  gap:16px;
}
.appHeader-left h1{
  font-size:1.1rem;
  font-weight:600;
  color:var(--text);
  display:flex;
  align-items:center;
  gap:8px;
  line-height:1.3;
  margin:0;
}
.badge-infinie{
  background:linear-gradient(90deg,var(--gold-2),var(--gold-3));
  color:#000;
  font-size:.7rem;
  font-weight:600;
  border-radius:999px;
  padding:3px 8px;
  line-height:1.2;
  border:1px solid rgba(0,0,0,.6);
  box-shadow:0 0 20px rgba(242,199,108,.4);
}
.appHeader-left .subtitle{
  font-size:.8rem;
  color:var(--muted);
  line-height:1.4;
  max-width:600px;
  margin-top:4px;
}

/* STATUS BOX GLOBAL */
#globalStatus{
  font-size:.8rem;
  font-weight:500;
  line-height:1.4;
  color:var(--text);
  background:rgba(16,18,24,0.6);
  border:1px solid var(--border);
  border-radius:var(--radius);
  padding:12px 16px;
  min-width:240px;
  max-width:320px;
  box-shadow:
    0 20px 60px rgba(0,0,0,.8),
    0 0 40px rgba(242,199,108,.12);
}
#globalStatus .stateLine{
  margin-bottom:4px;
  display:flex;
  justify-content:space-between;
  gap:10px;
  font-size:.75rem;
  color:var(--muted);
}
#globalStatus .stateLine span.value{
  color:var(--gold-2);
  font-weight:600;
}

/* GRID PANELS */
main{
  position:relative;
  z-index:2;
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(min(400px,100%),1fr));
  gap:24px;
  width:100%;
}

/* PANEL CARD LOOK */
.panel{
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:var(--radius);
  padding:16px 16px 20px;
  box-shadow:
    0 30px 120px rgba(0,0,0,.9),
    0 0 80px rgba(242,199,108,.18);
  backdrop-filter:blur(10px);
  position:relative;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  gap:12px;
}

.panelHead{
  display:flex;
  flex-wrap:wrap;
  align-items:flex-start;
  gap:10px;
}
.stepBadge{
  background:rgba(242,199,108,0.1);
  color:var(--gold-2);
  font-size:.7rem;
  border:1px solid var(--border);
  border-radius:999px;
  padding:2px 8px;
  line-height:1.2;
  font-weight:500;
}
.panelDesc{
  font-size:.7rem;
  color:var(--muted);
  line-height:1.4;
  max-width:90%;
}

/* FIELDS */
.fieldGroup{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.labelRow{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  justify-content:space-between;
  gap:6px;
  font-size:.7rem;
  font-weight:500;
  color:var(--text);
}
.labelRow small{
  font-weight:400;
  color:var(--muted);
  font-size:.65rem;
  line-height:1.3;
}

/* INPUTS */
input[type="file"],
textarea,
button.actionBtn,
input[type="number"]{
  font-family:var(--font-stack);
  font-size:.75rem;
  line-height:1.4;
  border-radius:var(--radius);
  border:1px solid var(--border);
  background:rgba(10,10,11,.4);
  color:var(--text);
  padding:10px 12px;
  width:100%;
  box-sizing:border-box;
  outline:none;
  box-shadow:0 0 20px rgba(242,199,108,0);
  transition:box-shadow .18s, border .18s, background .18s;
}
textarea{
  min-height:80px;
  resize:vertical;
  font-family:"SFMono-Regular","Courier New",monospace;
  font-size:.7rem;
  line-height:1.4;
  white-space:pre;
  color:var(--text);
}

/* focus glow doré */
input[type="file"]:focus,
textarea:focus,
input[type="number"]:focus{
  border:1px solid var(--gold-2);
  box-shadow:0 0 20px rgba(242,199,108,.4);
  background:rgba(16,18,24,.9);
}

/* BOUTON STYLE OR */
button.actionBtn{
  cursor:pointer;
  font-weight:600;
  color:#000;
  background:linear-gradient(90deg,var(--gold-2),var(--gold-3));
  border:1px solid rgba(0,0,0,.6);
  box-shadow:
    0 10px 40px rgba(242,199,108,.45),
    0 0 60px rgba(242,199,108,.3);
  text-shadow:0 0 20px rgba(0,0,0,.6);
}
button.actionBtn:disabled{
  opacity:.4;
  cursor:not-allowed;
  box-shadow:none;
  filter:grayscale(1);
}

/* TEXTES INFO */
.infoText{
  font-size:.7rem;
  color:var(--muted);
  line-height:1.4;
  word-break:break-word;
}
.infoText strong{
  color:var(--gold-2);
  font-weight:600;
}

/* PETIT <code> doré discret */
code{
  background:rgba(242,199,108,0.08);
  border:1px solid var(--border);
  border-radius:6px;
  padding:0 4px;
  color:var(--gold-2);
  font-size:.7rem;
  font-family:"SFMono-Regular","Courier New",monospace;
}

/* QUALITÉ DATASET */
.meterStatus{
  font-size:.7rem;
  line-height:1.4;
  font-weight:500;
}
.meterStatus.good{ color:var(--ok); }
.meterStatus.warn{ color:var(--warn); }
.meterStatus.bad{ color:var(--danger); }

/* PREVIEWS */
.previewBox{
  background:rgba(0,0,0,.25);
  border:1px solid rgba(255,255,255,.05);
  border-radius:var(--radius);
  padding:8px 10px;
  font-size:.7rem;
  line-height:1.4;
  color:var(--text);
  font-family:"SFMono-Regular","Courier New",monospace;
  white-space:pre-wrap;
  word-break:break-word;
  max-height:120px;
  overflow:auto;
  box-sizing:border-box;
}
.previewInline{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  font-size:.7rem;
  line-height:1.4;
  color:var(--text);
}
.previewChip{
  background:rgba(242,199,108,.08);
  border:1px solid var(--border);
  border-radius:999px;
  padding:2px 8px;
  font-size:.65rem;
  line-height:1.3;
  color:var(--gold-2);
  font-weight:500;
  white-space:nowrap;
}

/* MODELE ENTRAINE */
#trainedModelOutput{
  background:rgba(0,0,0,.4);
  border:1px solid var(--border);
  border-radius:var(--radius);
  color:var(--gold-2);
  padding:12px;
  font-size:.7rem;
  line-height:1.4;
  font-family:"SFMono-Regular","Courier New",monospace;
  max-height:200px;
  overflow:auto;
  white-space:pre;
  box-shadow:0 0 40px rgba(242,199,108,.25);
  box-sizing:border-box;
}

/* META ENTRAINEMENT */
.statsRow{
  display:flex;
  flex-wrap:wrap;
  row-gap:4px;
  column-gap:12px;
  font-size:.7rem;
  line-height:1.4;
  color:var(--muted);
}
.statsRow div{
  display:flex;
  flex-direction:column;
  min-width:90px;
}
.statsRow span.label{
  color:var(--muted);
  font-size:.65rem;
  line-height:1.3;
}
.statsRow span.value{
  color:var(--gold-2);
  font-weight:500;
  font-size:.75rem;
  line-height:1.4;
}

/* STATUT ENTRAINEMENT */
#trainingStatus{
  font-size:.7rem;
  line-height:1.4;
  min-height:1.4em;
  color:var(--gold-2);
  font-weight:500;
  word-break:break-word;
}

/* NOTE EXPORT */
.exportNote{
  font-size:.7rem;
  color:var(--muted);
  line-height:1.4;
  border-top:1px solid rgba(242,199,108,.15);
  padding-top:12px;
}

/* UTILS */
.hidden{display:none!important;}
</style>
</head>
<body>

<!-- HEADER PRINCIPAL -->
<div class="appHeader">
  <div class="appHeader-left">
    <h1>
      <span>Entraîneur de Modèle IA</span>
      <span class="badge-infinie">∞ Infinie & gratuit</span>
    </h1>
    <div class="subtitle">
      Réentraîne ton modèle (régression ridge) en local. Zéro serveur, 100% offline.
    </div>
  </div>

  <div id="globalStatus">
    <div class="stateLine"><span>Modèle :</span><span class="value" id="statusModel">non</span></div>
    <div class="stateLine"><span>Dataset :</span><span class="value" id="statusData">0 ligne</span></div>
    <div class="stateLine"><span>Entraînement :</span><span class="value" id="statusTrain">en attente</span></div>
  </div>
</div>

<main>

  <!-- PANEL A : MODELE -->
  <section class="panel" id="panelA">
    <div class="panelHead">
      <span class="stepBadge">1. Charger le modèle existant</span>
    </div>
    <div class="panelDesc">
      Importe ton page HTML actuelle ou colle son code. On va extraire l'objet <code>model</code> (features, coefficients, intercept).
    </div>

    <div class="fieldGroup">
      <div class="labelRow">
        <label for="modelFile">Fichier modèle (.html / .txt)</label>
        <small>Option 1</small>
      </div>
      <input type="file" id="modelFile" accept=".html,.txt,.htm,.js"/>
    </div>

    <div class="fieldGroup">
      <div class="labelRow">
        <label for="modelText">Ou colle le code source complet</label>
        <small>Option 2</small>
      </div>
      <textarea id="modelText" placeholder="Colle ici le contenu complet d'un index.html qui contient model = { feature_order:[...], coefficients:[...], intercept:... }"></textarea>
    </div>

    <div class="fieldGroup">
      <button class="actionBtn" id="parseModelBtn" type="button">Analyser / Extraire le modèle</button>
    </div>

    <div class="fieldGroup infoText" id="modelInfoBox">
      <div><strong>Features détectées :</strong> <span id="modelFeatureCount">-</span></div>
      <div class="previewInline" id="modelFeatureList"></div>

      <div style="margin-top:6px;"><strong>Intercept :</strong> <span id="modelIntercept">-</span></div>

      <div style="margin-top:6px;">
        <strong>Coefficients (aperçu) :</strong>
        <div class="previewBox" id="modelCoefPreview"></div>
      </div>

      <div style="margin-top:6px;">
        <strong>Statut extraction :</strong>
        <span id="modelStatusMsg" style="color:var(--warn)">Aucun modèle chargé</span>
      </div>
    </div>
  </section>

  <!-- PANEL B : DATASET -->
  <section class="panel" id="panelB">
    <div class="panelHead">
      <span class="stepBadge">2. Charger les données d’entraînement</span>
    </div>
    <div class="panelDesc">
      Colle ou importe un gros CSV (millions de lignes possibles). Parsing incrémental, pas de backend.
    </div>

    <div class="fieldGroup">
      <div class="labelRow">
        <label for="dataText">Coller des lignes CSV</label>
        <small>Ex: surface_bien_m2,...,prix</small>
      </div>
      <textarea id="dataText" placeholder="surface_bien_m2,surface_terrain_m2,pieces,parking_places,departement,zone_type,type_bien,etat_bien,dernier_etage,ascenseur,exterieur_m2,prix
82,120,4,1,13,centre_urbain,appart,refait,1,1,6,289000"></textarea>
    </div>

    <div class="fieldGroup">
      <div class="labelRow">
        <label for="dataFile">Ou fichier .csv / .txt</label>
        <small>gros dataset autorisé</small>
      </div>
      <input type="file" id="dataFile" accept=".csv,.txt"/>
    </div>

    <div class="fieldGroup">
      <button class="actionBtn" id="parseDataBtn" type="button">Analyser / Accumuler le dataset</button>
    </div>

    <div class="fieldGroup infoText">
      <div><strong>Lignes valides :</strong> <span id="dataLineCount">0</span></div>
      <div id="dataQuality" class="meterStatus bad">Aucune donnée</div>

      <div style="margin-top:6px;"><strong>Preview parsing (quelques lignes) :</strong></div>
      <div class="previewBox" id="dataPreviewBox"></div>
    </div>
  </section>

  <!-- PANEL C : ENTRAINER -->
  <section class="panel" id="panelC">
    <div class="panelHead">
      <span class="stepBadge">3. Entraîner maintenant</span>
    </div>
    <div class="panelDesc">
      Régression linéaire Ridge locale :
      β = (XᵀX + λI)<sup>-1</sup> Xᵀy.
      Lambda stabilise le modèle.
    </div>

    <div class="fieldGroup">
      <div class="labelRow">
        <label for="lambdaInput">λ (ridge)</label>
        <small>défaut = 1.0</small>
      </div>
      <input id="lambdaInput" type="number" min="0" step="0.1" value="1.0" style="max-width:120px"/>
    </div>

    <div class="fieldGroup">
      <button class="actionBtn" id="trainBtn" type="button">Lancer l'entraînement</button>
      <div id="trainingStatus">en attente…</div>
    </div>

    <div class="fieldGroup">
      <div class="labelRow">
        <label>Modèle entraîné (JSON)</label>
        <small>sera utilisé pour l'export</small>
      </div>
      <pre id="trainedModelOutput">{}</pre>
    </div>

    <div class="statsRow" id="trainMeta">
      <div>
        <span class="label">Lignes utilisées</span>
        <span class="value" id="metaLines">-</span>
      </div>
      <div>
        <span class="label"># Features</span>
        <span class="value" id="metaFeat">-</span>
      </div>
      <div>
        <span class="label">λ Ridge</span>
        <span class="value" id="metaLambda">-</span>
      </div>
      <div>
        <span class="label">Horodatage</span>
        <span class="value" id="metaTime">-</span>
      </div>
      <div>
        <span class="label">Avertissement</span>
        <span class="value" id="metaWarn">-</span>
      </div>
    </div>
  </section>

  <!-- PANEL D : EXPORT -->
  <section class="panel" id="panelD">
    <div class="panelHead">
      <span class="stepBadge">4. Exporter</span>
    </div>
    <div class="panelDesc">
      Télécharge soit le modèle entraîné (.json), soit un nouvel index.html déjà mis à jour.
    </div>

    <div class="fieldGroup">
      <button class="actionBtn" id="downloadJSONBtn" type="button" disabled>Télécharger le modèle (.json)</button>
    </div>

    <div class="fieldGroup">
      <button class="actionBtn" id="downloadHTMLBtn" type="button" disabled>Générer index.html entraîné</button>
    </div>

    <div class="exportNote">
      Tu peux publier ce nouvel index.html direct (Netlify, static hébergé, etc.).
      Le modèle est gelé dans le code, pas besoin d’API.
    </div>
  </section>

</main>

<script>
"use strict";

/* ─────────────────────────────────────────────
   ÉTAT GLOBAL
   ───────────────────────────────────────────── */
let originalModelSourceText = "";
let loadedModel = null;         // { feature_order, coefficients, intercept }
let trainedModel = null;        // output ridge final (avec meta)
let trainingStats = {};         // meta affichées
let globalFeatureOrder = [];    // ordre des features
let XT_X = null;                // matrice somme(x^T x)
let XT_y = null;                // vecteur somme(x^T y)
let totalRows = 0;
let previewSamples = [];
let parsingInProgress = false;

/* ─────────────────────────────────────────────
   RÉFÉRENCES DOM (pour éviter 10k getElementById)
   ───────────────────────────────────────────── */
const el_statusModel      = document.getElementById("statusModel");
const el_statusData       = document.getElementById("statusData");
const el_statusTrain      = document.getElementById("statusTrain");

const el_modelFile        = document.getElementById("modelFile");
const el_modelText        = document.getElementById("modelText");
const el_modelFeatureCt   = document.getElementById("modelFeatureCount");
const el_modelFeatureList = document.getElementById("modelFeatureList");
const el_modelIntercept   = document.getElementById("modelIntercept");
const el_modelCoefPrev    = document.getElementById("modelCoefPreview");
const el_modelStatusMsg   = document.getElementById("modelStatusMsg");

const el_dataText         = document.getElementById("dataText");
const el_dataFile         = document.getElementById("dataFile");
const el_dataLineCount    = document.getElementById("dataLineCount");
const el_dataQuality      = document.getElementById("dataQuality");
const el_dataPreviewBox   = document.getElementById("dataPreviewBox");

const el_lambdaInput      = document.getElementById("lambdaInput");
const el_trainingStatus   = document.getElementById("trainingStatus");
const el_trainedOut       = document.getElementById("trainedModelOutput");
const el_metaLines        = document.getElementById("metaLines");
const el_metaFeat         = document.getElementById("metaFeat");
const el_metaLambda       = document.getElementById("metaLambda");
const el_metaTime         = document.getElementById("metaTime");
const el_metaWarn         = document.getElementById("metaWarn");

const el_btnParseModel    = document.getElementById("parseModelBtn");
const el_btnParseData     = document.getElementById("parseDataBtn");
const el_btnTrain         = document.getElementById("trainBtn");
const el_btnDownloadJSON  = document.getElementById("downloadJSONBtn");
const el_btnDownloadHTML  = document.getElementById("downloadHTMLBtn");

/* ─────────────────────────────────────────────
   HELPERS UI
   ───────────────────────────────────────────── */
function fmtNb(n){
  if(Number.isFinite(n)) return n.toLocaleString('fr-FR');
  return n;
}
function updateGlobalStatus(){
  el_statusModel.textContent = loadedModel ? "oui" : "non";
  el_statusData.textContent  = totalRows>0 ? (fmtNb(totalRows)+" lignes") : "0 ligne";
  el_statusTrain.textContent = trainedModel ? "terminé ✔" : "en attente";
}

/* ─────────────────────────────────────────────
   PANEL A : EXTRACTION DU MODELE
   ─────────────────────────────────────────────
   On cherche var/let/const model = { ... };
*/
function extractModelFromText(txt){
  originalModelSourceText = txt;

  const regex = /(const|let|var)\s+model\s*=\s*({[\s\S]*?});/;
  const match = txt.match(regex);
  if(!match){
    return {error:"Impossible de trouver 'model = {...}' dans ce fichier."};
  }

  const objCode = match[2].trim(); // le { ... }

  let parsed;
  try{
    // on exécute seulement un "return { ... }"
    parsed = (new Function("return "+objCode+";"))();
  }catch(e){
    return {error:"Le modèle est trouvé mais illisible : "+e.message};
  }

  if(!parsed || !parsed.feature_order || !parsed.coefficients){
    return {error:"L'objet 'model' est incomplet (il doit contenir feature_order & coefficients)."};
  }

  return {model:parsed};
}

function displayLoadedModel(res){
  if(res.error){
    el_modelStatusMsg.style.color = "var(--danger)";
    el_modelStatusMsg.textContent = res.error;
    loadedModel = null;
    updateGlobalStatus();
    return;
  }

  loadedModel = res.model;
  // si le modèle fournit son propre ordre, on l'adopte direct
  if(Array.isArray(loadedModel.feature_order)){
    globalFeatureOrder = loadedModel.feature_order.slice();
  }

  el_modelStatusMsg.style.color = "var(--ok)";
  el_modelStatusMsg.textContent = "Modèle chargé ✔";

  // nb features
  if(loadedModel.feature_order){
    el_modelFeatureCt.textContent = loadedModel.feature_order.length+" features";
    el_modelFeatureList.innerHTML = "";
    loadedModel.feature_order.slice(0,50).forEach(f=>{
      const chip = document.createElement("div");
      chip.className="previewChip";
      chip.textContent = f;
      el_modelFeatureList.appendChild(chip);
    });
  }else{
    el_modelFeatureCt.textContent = "-";
    el_modelFeatureList.innerHTML = "";
  }

  el_modelIntercept.textContent = (""+loadedModel.intercept);
  el_modelCoefPrev.textContent =
    JSON.stringify(loadedModel.coefficients.slice(0,5));

  updateGlobalStatus();
}

function handleParseModel(){
  // priorité fichier si dispo
  if(el_modelFile.files && el_modelFile.files[0]){
    const reader = new FileReader();
    reader.onload = e=>{
      const txt = e.target.result;
      const parsed = extractModelFromText(txt);
      displayLoadedModel(parsed);
    };
    reader.readAsText(el_modelFile.files[0]);
  }else{
    const txt = el_modelText.value || "";
    const parsed = extractModelFromText(txt);
    displayLoadedModel(parsed);
  }
}

/* ─────────────────────────────────────────────
   PANEL B : DATASET / STREAM CSV
   ─────────────────────────────────────────────
   Format de ligne attendu (ex immobilier) :
   surface_bien_m2,surface_terrain_m2,pieces,parking_places,departement,zone_type,type_bien,etat_bien,dernier_etage,ascenseur,exterieur_m2,prix
*/
function parseTrainingRow(line){
  const parts = line.split(",");
  if(parts.length < 12) return null;

  function toNum(v){
    const n = parseFloat(v.trim());
    return Number.isFinite(n)?n:0;
  }

  const row = {
    surface_bien_m2:     toNum(parts[0]),
    surface_terrain_m2:  toNum(parts[1]),
    pieces:              toNum(parts[2]),
    parking_places:      toNum(parts[3]),
    departement:         parts[4].trim(),
    zone_type:           parts[5].trim(),
    type_bien:           parts[6].trim(),
    etat_bien:           parts[7].trim(),
    dernier_etage:       toNum(parts[8]),
    ascenseur:           toNum(parts[9]),
    exterieur_m2:        toNum(parts[10]),
    price:               toNum(parts[11])
  };
  return row;
}

/* on crée / étend l'espace de features quand pas fourni */
function expandFeatureOrderFromRow(row){
  const baseFeat = {
    surface_bien_m2:1,
    surface_terrain_m2:1,
    pieces:1,
    parking_places:1,
    dernier_etage:1,
    ascenseur:1,
    exterieur_m2:1
  };
  baseFeat["dep_"+row.departement]=1;
  baseFeat["zone_"+row.zone_type]=1;
  baseFeat["type_"+row.type_bien]=1;
  baseFeat["etat_"+row.etat_bien]=1;

  const keys = Object.keys(baseFeat);
  for(let k of keys){
    if(globalFeatureOrder.indexOf(k)===-1){
      globalFeatureOrder.push(k);
    }
  }
}

/* convertit 1 ligne -> vecteur X selon globalFeatureOrder */
function buildFeatureVector(row, featureOrderRef){
  const featMap = {
    surface_bien_m2: row.surface_bien_m2,
    surface_terrain_m2: row.surface_terrain_m2,
    pieces: row.pieces,
    parking_places: row.parking_places,
    dernier_etage: row.dernier_etage,
    ascenseur: row.ascenseur,
    exterieur_m2: row.exterieur_m2
  };
  featMap["dep_"+row.departement]=1;
  featMap["zone_"+row.zone_type]=1;
  featMap["type_"+row.type_bien]=1;
  featMap["etat_"+row.etat_bien]=1;

  const vec = new Array(featureOrderRef.length).fill(0);
  for(let i=0;i<featureOrderRef.length;i++){
    const key = featureOrderRef[i];
    if(featMap[key]!==undefined){
      vec[i] = featMap[key];
    }
  }
  return vec;
}

/* accumule XᵀX et Xᵀy sans stocker toutes les lignes */
function accumulateXT_XTy(vec, y){
  const f = vec.length;
  if(!XT_X){
    XT_X = [];
    for(let i=0;i<f;i++){
      XT_X[i]=new Float64Array(f);
    }
  }
  if(!XT_y){
    XT_y = new Float64Array(f);
  }

  for(let i=0;i<f;i++){
    const vi = vec[i];
    XT_y[i] += vi * y;
    for(let j=0;j<f;j++){
      XT_X[i][j] += vi * vec[j];
    }
  }
}

/* qualité dataset */
function computeQualityText(n){
  if(n<1)    return {txt:"Aucune donnée", cls:"bad"};
  if(n<200)  return {txt:"Données insuffisantes (modèle peu fiable)", cls:"bad"};
  if(n<1000) return {txt:"Volume de base (démo ok)", cls:"warn"};
  if(n<5000) return {txt:"Bon volume (modèle sérieux)", cls:"good"};
  if(n<100000) return {txt:"Très bon volume (modèle robuste)", cls:"good"};
  return {txt:"Dataset massif (attention perf navigateur)", cls:"warn"};
}

function refreshDataUI(){
  el_dataLineCount.textContent = fmtNb(totalRows);
  const q = computeQualityText(totalRows);
  el_dataQuality.textContent = q.txt;
  el_dataQuality.className = "meterStatus "+q.cls;
  el_dataPreviewBox.textContent = previewSamples.slice(0,10).join("\n");
  updateGlobalStatus();
}

/* lit un morceau de fichier */
function readFileSlice(blob){
  return new Promise((resolve,reject)=>{
    const fr = new FileReader();
    fr.onload = e=>resolve(e.target.result);
    fr.onerror = e=>reject(e);
    fr.readAsText(blob);
  });
}

/* micro pause pour laisser respirer le navigateur */
function microYield(){
  return new Promise(res=>setTimeout(res,0));
}

/* traite UNE ligne CSV */
function processTrainingLine(line){
  const row = parseTrainingRow(line);
  if(!row) return;

  if(globalFeatureOrder.length===0 && !(loadedModel && loadedModel.feature_order)){
    expandFeatureOrderFromRow(row);
  }

  const vec = buildFeatureVector(row, globalFeatureOrder);
  accumulateXT_XTy(vec, row.price);

  totalRows++;
  if(previewSamples.length<20){
    previewSamples.push(line.trim());
  }
}

/* streaming gros fichier */
async function parseLargeFile(file){
  parsingInProgress = true;

  const chunkSize = 1024*1024; // 1Mo
  let offset = 0;
  let remainder = "";

  while(offset < file.size){
    const slice = file.slice(offset, offset+chunkSize);
    const textChunk = await readFileSlice(slice);
    offset += chunkSize;

    const combined = remainder + textChunk;
    const lines = combined.split(/\r?\n/);
    remainder = lines.pop() || "";

    for(const line of lines){
      processTrainingLine(line);
    }
    refreshDataUI();
    await microYield();
  }

  if(remainder){
    processTrainingLine(remainder);
  }

  parsingInProgress = false;
  refreshDataUI();
}

/* analyse dataset : textarea OU fichier */
async function handleParseData(){
  if(parsingInProgress) return;

  // reset état dataset à chaque clic
  XT_X = null;
  XT_y = null;
  totalRows = 0;
  previewSamples = [];

  // si modèle déjà chargé => on respecte SON ordre de features
  if(loadedModel && Array.isArray(loadedModel.feature_order)){
    globalFeatureOrder = loadedModel.feature_order.slice();
  }else{
    // sinon on reconstruit fresh
    if(!Array.isArray(globalFeatureOrder)) globalFeatureOrder=[];
    globalFeatureOrder.length = 0;
  }

  const textVal = (el_dataText.value||"").trim();
  const fileObj = el_dataFile.files && el_dataFile.files[0] ? el_dataFile.files[0] : null;

  if(textVal){
    const lines = textVal.split(/\r?\n/);
    for(const line of lines){
      processTrainingLine(line);
    }
    refreshDataUI();
  }else if(fileObj){
    await parseLargeFile(fileObj);
  }else{
    alert("Aucune donnée fournie.");
  }
}

/* ─────────────────────────────────────────────
   PANEL C : RÉGRESSION RIDGE
   beta = (XᵀX + λI)^(-1) Xᵀy
   On garde intercept=0 pour cette version (simple).
   ───────────────────────────────────────────── */
function invertMatrix(m){
  const n = m.length;
  // [m | I]
  const A = [];
  for(let i=0;i<n;i++){
    A[i] = new Float64Array(n*2);
    for(let j=0;j<n;j++){
      A[i][j] = m[i][j];
    }
    A[i][n+i] = 1;
  }
  // Gauss-Jordan
  for(let i=0;i<n;i++){
    let pivot = A[i][i];
    if(Math.abs(pivot)<1e-12){
      for(let r=i+1;r<n;r++){
        if(Math.abs(A[r][i])>Math.abs(pivot)){
          const tmp = A[i]; A[i]=A[r]; A[r]=tmp;
          break;
        }
      }
      pivot = A[i][i];
      if(Math.abs(pivot)<1e-12){
        throw new Error("Matrice quasi-singulière");
      }
    }
    const invPivot = 1/pivot;
    for(let c=0;c<2*n;c++){
      A[i][c]*=invPivot;
    }
    for(let r=0;r<n;r++){
      if(r===i) continue;
      const factor = A[r][i];
      if(factor!==0){
        for(let c=0;c<2*n;c++){
          A[r][c]-=factor*A[i][c];
        }
      }
    }
  }
  const inv = [];
  for(let i=0;i<n;i++){
    inv[i]=new Float64Array(n);
    for(let j=0;j<n;j++){
      inv[i][j]=A[i][n+j];
    }
  }
  return inv;
}

function solveRidge(lambda){
  if(!XT_X || !XT_y){
    throw new Error("Pas de données (XT_X / XT_y vides).");
  }
  const f = XT_y.length;

  // A = XT_X + λI
  const A = [];
  for(let i=0;i<f;i++){
    A[i]=new Float64Array(f);
    for(let j=0;j<f;j++){
      let v = XT_X[i][j];
      if(i===j){ v += lambda; }
      A[i][j]=v;
    }
  }

  const invA = invertMatrix(A);

  const beta = new Float64Array(f);
  for(let i=0;i<f;i++){
    let s=0;
    for(let j=0;j<f;j++){
      s+=invA[i][j]*XT_y[j];
    }
    beta[i]=s;
  }

  return {
    coefficients:Array.from(beta),
    intercept:0
  };
}

function handleTrain(){
  if(!XT_X || !XT_y || totalRows===0){
    alert("Pas de dataset prêt (Étape 2).");
    return;
  }
  if(globalFeatureOrder.length===0){
    alert("Aucun espace de features défini.");
    return;
  }

  const lambdaVal = parseFloat(el_lambdaInput.value)||1.0;
  el_btnTrain.disabled = true;
  el_trainingStatus.textContent = "Entraînement en cours…";

  let ridgeResult;
  try{
    ridgeResult = solveRidge(lambdaVal);
  }catch(e){
    el_trainingStatus.textContent = "Erreur entraînement : "+e.message;
    el_btnTrain.disabled = false;
    return;
  }

  trainedModel = {
    feature_order: globalFeatureOrder.slice(),
    coefficients:  ridgeResult.coefficients.slice(),
    intercept:     ridgeResult.intercept,
    meta:{
      nb_lignes_utilisées: totalRows,
      nb_features: globalFeatureOrder.length,
      lambda_utilisé: lambdaVal,
      horodatage: new Date().toLocaleString('fr-FR')
    }
  };

  // avertissement
  let warn="";
  if(totalRows<200){
    warn="ATTENTION: Sous-entraîné";
  }else if(globalFeatureOrder.length>totalRows){
    warn="Risque de sur-ajustement (trop de colonnes / peu de lignes)";
  }else{
    warn="Modèle prêt à publier";
  }
  trainedModel.meta.avertissement = warn;

  // UI
  el_trainedOut.textContent = JSON.stringify(trainedModel,null,2);
  el_metaLines.textContent  = fmtNb(totalRows);
  el_metaFeat.textContent   = fmtNb(globalFeatureOrder.length);
  el_metaLambda.textContent = lambdaVal;
  el_metaTime.textContent   = trainedModel.meta.horodatage;
  el_metaWarn.textContent   = warn;

  el_trainingStatus.textContent = "Terminé ✔";
  el_btnTrain.disabled = false;

  // activer export
  el_btnDownloadJSON.disabled = false;
  el_btnDownloadHTML.disabled = false;

  updateGlobalStatus();
}

/* ─────────────────────────────────────────────
   PANEL D : EXPORT
   ───────────────────────────────────────────── */
function downloadJSON(){
  if(!trainedModel){
    alert("Pas de modèle entraîné.");
    return;
  }
  const blob = new Blob(
    [JSON.stringify(trainedModel,null,2)],
    {type:"application/json"}
  );
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "modele_entraine.json";
  a.click();
  URL.revokeObjectURL(a.href);
}

/* remplace le bloc model = {...}; dans le HTML d'origine */
function downloadTrainedHTML(){
  if(!trainedModel){
    alert("Pas de modèle entraîné.");
    return;
  }
  if(!originalModelSourceText){
    alert("Tu dois d'abord charger la page source à l'étape 1.");
    return;
  }

  const newModelCode =
    "const model = "+JSON.stringify({
      feature_order:trainedModel.feature_order,
      coefficients:trainedModel.coefficients,
      intercept:trainedModel.intercept
    },null,2)+";";

  const regex = /(const|let|var)\s+model\s*=\s*{[\s\S]*?};/;

  let outputHTML="";
  if(regex.test(originalModelSourceText)){
    outputHTML = originalModelSourceText.replace(regex,newModelCode);
  }else{
    // si pas trouvé on ajoute à la fin
    outputHTML = originalModelSourceText+
      "\n<!-- Modèle mis à jour -->\n<script>\n"+newModelCode+"\n</script>\n";
  }

  const blob = new Blob([outputHTML],{type:"text/html"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "index_trained.html";
  a.click();
  URL.revokeObjectURL(a.href);
}

/* ─────────────────────────────────────────────
   EVENTS
   ───────────────────────────────────────────── */
el_btnParseModel.addEventListener("click",handleParseModel);
el_btnParseData.addEventListener("click",handleParseData);
el_btnTrain.addEventListener("click",handleTrain);
el_btnDownloadJSON.addEventListener("click",downloadJSON);
el_btnDownloadHTML.addEventListener("click",downloadTrainedHTML);

updateGlobalStatus();
</script>
</body>
</html>
